{"ast":null,"code":"// src/suspense.ts\nvar defaultThrowOnError = function defaultThrowOnError(_error, query) {\n  return query.state.data === void 0;\n};\nvar ensureSuspenseTimers = function ensureSuspenseTimers(defaultedOptions) {\n  if (defaultedOptions.suspense) {\n    var clamp = function clamp(value) {\n      return value === \"static\" ? value : Math.max(value !== null && value !== void 0 ? value : 1e3, 1e3);\n    };\n    var originalStaleTime = defaultedOptions.staleTime;\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? function () {\n      return clamp(originalStaleTime.apply(void 0, arguments));\n    } : clamp(originalStaleTime);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = function willFetch(result, isRestoring) {\n  return result.isLoading && result.isFetching && !isRestoring;\n};\nvar shouldSuspend = function shouldSuspend(defaultedOptions, result) {\n  return (defaultedOptions === null || defaultedOptions === void 0 ? void 0 : defaultedOptions.suspense) && result.isPending;\n};\nvar fetchOptimistic = function fetchOptimistic(defaultedOptions, observer, errorResetBoundary) {\n  return observer.fetchOptimistic(defaultedOptions).catch(function () {\n    errorResetBoundary.clearReset();\n  });\n};\nexport { defaultThrowOnError, ensureSuspenseTimers, fetchOptimistic, shouldSuspend, willFetch };","map":{"version":3,"names":["defaultThrowOnError","_error","query","state","data","ensureSuspenseTimers","defaultedOptions","suspense","clamp","value","Math","max","originalStaleTime","staleTime","apply","arguments","gcTime","willFetch","result","isRestoring","isLoading","isFetching","shouldSuspend","isPending","fetchOptimistic","observer","errorResetBoundary","catch","clearReset"],"sources":["C:\\Users\\als40\\Desktop\\HandsMarket\\node_modules\\@tanstack\\react-query\\src\\suspense.ts"],"sourcesContent":["import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static' ? value : Math.max(value ?? 1000, 1000)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n"],"mappings":";AAUO,IAAMA,mBAAA,GAAsB,SAAtBA,oBAMXC,MAAA,EACAC,KAAA;EAAA,OACGA,KAAA,CAAMC,KAAA,CAAMC,IAAA,KAAS;AAAA;AAEnB,IAAMC,oBAAA,GAAuB,SAAvBA,qBACXC,gBAAA,EACG;EACH,IAAIA,gBAAA,CAAiBC,QAAA,EAAU;IAI7B,IAAMC,KAAA,GAAQ,SAARA,MAASC,KAAA;MAAA,OACbA,KAAA,KAAU,WAAWA,KAAA,GAAQC,IAAA,CAAKC,GAAA,CAAIF,KAAA,aAAAA,KAAA,cAAAA,KAAA,GAAS,KAAM,GAAI;IAAA;IAE3D,IAAMG,iBAAA,GAAoBN,gBAAA,CAAiBO,SAAA;IAC3CP,gBAAA,CAAiBO,SAAA,GACf,OAAOD,iBAAA,KAAsB,aACzB;MAAA,OAAaJ,KAAA,CAAMI,iBAAA,CAAAE,KAAA,SAAAC,SAAyB,CAAC;IAAA,IAC7CP,KAAA,CAAMI,iBAAiB;IAE7B,IAAI,OAAON,gBAAA,CAAiBU,MAAA,KAAW,UAAU;MAC/CV,gBAAA,CAAiBU,MAAA,GAASN,IAAA,CAAKC,GAAA,CAAIL,gBAAA,CAAiBU,MAAA,EAAQ,GAAI;IAClE;EACF;AACF;AAEO,IAAMC,SAAA,GAAY,SAAZA,UACXC,MAAA,EACAC,WAAA;EAAA,OACGD,MAAA,CAAOE,SAAA,IAAaF,MAAA,CAAOG,UAAA,IAAc,CAACF,WAAA;AAAA;AAExC,IAAMG,aAAA,GAAgB,SAAhBA,cACXhB,gBAAA,EAGAY,MAAA;EAAA,OACG,CAAAZ,gBAAA,aAAAA,gBAAA,uBAAAA,gBAAA,CAAkBC,QAAA,KAAYW,MAAA,CAAOK,SAAA;AAAA;AAEnC,IAAMC,eAAA,GAAkB,SAAlBA,gBAOXlB,gBAAA,EAOAmB,QAAA,EACAC,kBAAA;EAAA,OAEAD,QAAA,CAASD,eAAA,CAAgBlB,gBAAgB,EAAEqB,KAAA,CAAM,YAAM;IACrDD,kBAAA,CAAmBE,UAAA,CAAW;EAChC,CAAC;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}