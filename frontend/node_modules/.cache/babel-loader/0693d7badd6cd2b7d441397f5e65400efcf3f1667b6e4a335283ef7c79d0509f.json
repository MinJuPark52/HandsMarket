{"ast":null,"code":"\"use client\";\n\n// src/useQueries.ts\nimport _slicedToArray from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"queries\"];\nimport * as React from \"react\";\nimport { QueriesObserver, QueryObserver, noop, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureSuspenseTimers, fetchOptimistic, shouldSuspend, willFetch } from \"./suspense.js\";\nfunction useQueries(_ref, queryClient) {\n  var queries = _ref.queries,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var client = useQueryClient(queryClient);\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedQueries = React.useMemo(function () {\n    return queries.map(function (opts) {\n      var defaultedOptions = client.defaultQueryOptions(opts);\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    });\n  }, [queries, client, isRestoring]);\n  defaultedQueries.forEach(function (query) {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  var _React$useState = React.useState(function () {\n      return new QueriesObserver(client, defaultedQueries, options);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    observer = _React$useState2[0];\n  var _observer$getOptimist = observer.getOptimisticResult(defaultedQueries, options.combine),\n    _observer$getOptimist2 = _slicedToArray(_observer$getOptimist, 3),\n    optimisticResult = _observer$getOptimist2[0],\n    getCombinedResult = _observer$getOptimist2[1],\n    trackResult = _observer$getOptimist2[2];\n  var shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n  }, [observer, shouldSubscribe]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    observer.setQueries(defaultedQueries, options);\n  }, [defaultedQueries, options, observer]);\n  var shouldAtLeastOneSuspend = optimisticResult.some(function (result, index) {\n    return shouldSuspend(defaultedQueries[index], result);\n  });\n  var suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap(function (result, index) {\n    var opts = defaultedQueries[index];\n    if (opts) {\n      var queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  var firstSingleResultWhichShouldThrow = optimisticResult.find(function (result, index) {\n    var query = defaultedQueries[index];\n    return query && getHasError({\n      result: result,\n      errorResetBoundary: errorResetBoundary,\n      throwOnError: query.throwOnError,\n      query: client.getQueryCache().get(query.queryHash),\n      suspense: query.suspense\n    });\n  });\n  if (firstSingleResultWhichShouldThrow !== null && firstSingleResultWhichShouldThrow !== void 0 && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport { useQueries };","map":{"version":3,"names":["React","QueriesObserver","QueryObserver","noop","notifyManager","useQueryClient","useIsRestoring","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureSuspenseTimers","fetchOptimistic","shouldSuspend","willFetch","useQueries","_ref","queryClient","queries","options","_objectWithoutProperties","_excluded","client","isRestoring","errorResetBoundary","defaultedQueries","useMemo","map","opts","defaultedOptions","defaultQueryOptions","_optimisticResults","forEach","query","_React$useState","useState","_React$useState2","_slicedToArray","observer","_observer$getOptimist","getOptimisticResult","combine","_observer$getOptimist2","optimisticResult","getCombinedResult","trackResult","shouldSubscribe","subscribed","useSyncExternalStore","useCallback","onStoreChange","subscribe","batchCalls","getCurrentResult","useEffect","setQueries","shouldAtLeastOneSuspend","some","result","index","suspensePromises","flatMap","queryObserver","length","Promise","all","firstSingleResultWhichShouldThrow","find","throwOnError","getQueryCache","get","queryHash","suspense","error"],"sources":["C:\\Users\\als40\\Desktop\\HandsMarket\\node_modules\\@tanstack\\react-query\\src\\useQueries.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}