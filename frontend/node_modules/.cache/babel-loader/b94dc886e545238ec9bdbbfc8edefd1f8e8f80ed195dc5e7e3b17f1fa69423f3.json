{"ast":null,"code":"\"use client\";\n\n// src/HydrationBoundary.tsx\nimport _createForOfIteratorHelper from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nvar HydrationBoundary = function HydrationBoundary(_ref) {\n  var children = _ref.children,\n    _ref$options = _ref.options,\n    options = _ref$options === void 0 ? {} : _ref$options,\n    state = _ref.state,\n    queryClient = _ref.queryClient;\n  var client = useQueryClient(queryClient);\n  var optionsRef = React.useRef(options);\n  optionsRef.current = options;\n  var hydrationQueue = React.useMemo(function () {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n      var queryCache = client.getQueryCache();\n      var queries = state.queries || [];\n      var newQueries = [];\n      var existingQueries = [];\n      var _iterator = _createForOfIteratorHelper(queries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dehydratedQuery = _step.value;\n          var existingQuery = queryCache.get(dehydratedQuery.queryHash);\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery);\n          } else {\n            var hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt || dehydratedQuery.promise && existingQuery.state.status !== \"pending\" && existingQuery.state.fetchStatus !== \"fetching\" && dehydratedQuery.dehydratedAt !== void 0 && dehydratedQuery.dehydratedAt > existingQuery.state.dataUpdatedAt;\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (newQueries.length > 0) {\n        hydrate(client, {\n          queries: newQueries\n        }, optionsRef.current);\n      }\n      if (existingQueries.length > 0) {\n        return existingQueries;\n      }\n    }\n    return void 0;\n  }, [client, state]);\n  React.useEffect(function () {\n    if (hydrationQueue) {\n      hydrate(client, {\n        queries: hydrationQueue\n      }, optionsRef.current);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\nexport { HydrationBoundary };","map":{"version":3,"names":["React","hydrate","useQueryClient","HydrationBoundary","_ref","children","_ref$options","options","state","queryClient","client","optionsRef","useRef","current","hydrationQueue","useMemo","queryCache","getQueryCache","queries","newQueries","existingQueries","_iterator","_createForOfIteratorHelper","_step","s","n","done","dehydratedQuery","value","existingQuery","get","queryHash","push","hydrationIsNewer","dataUpdatedAt","promise","status","fetchStatus","dehydratedAt","err","e","f","length","useEffect"],"sources":["C:\\Users\\als40\\Desktop\\HandsMarket\\node_modules\\@tanstack\\react-query\\src\\HydrationBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = (state as DehydratedState).queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"],"mappings":";;;;AACA,YAAYA,KAAA,MAAW;AAEvB,SAASC,OAAA,QAAe;AACxB,SAASC,cAAA,QAAsB;AAoBxB,IAAMC,iBAAA,GAAoB,SAApBA,kBAAAC,IAAA,EAKiB;EAAA,IAJ5BC,QAAA,GAAAD,IAAA,CAAAC,QAAA;IAAAC,YAAA,GAAAF,IAAA,CACAG,OAAA;IAAAA,OAAA,GAAAD,YAAA,cAAU,CAAC,IAAAA,YAAA;IACXE,KAAA,GAAAJ,IAAA,CAAAI,KAAA;IACAC,WAAA,GAAAL,IAAA,CAAAK,WAAA;EAEA,IAAMC,MAAA,GAASR,cAAA,CAAeO,WAAW;EAEzC,IAAME,UAAA,GAAmBX,KAAA,CAAAY,MAAA,CAAOL,OAAO;EACvCI,UAAA,CAAWE,OAAA,GAAUN,OAAA;EAiBrB,IAAMO,cAAA,GACEd,KAAA,CAAAe,OAAA,CAAQ,YAAM;IAClB,IAAIP,KAAA,EAAO;MACT,IAAI,OAAOA,KAAA,KAAU,UAAU;QAC7B;MACF;MAEA,IAAMQ,UAAA,GAAaN,MAAA,CAAOO,aAAA,CAAc;MAKxC,IAAMC,OAAA,GAAWV,KAAA,CAA0BU,OAAA,IAAW,EAAC;MAEvD,IAAMC,UAAA,GAAyC,EAAC;MAChD,IAAMC,eAAA,GAA8C,EAAC;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CACvBJ,OAAA;QAAAK,KAAA;MAAA;QAA9B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAuC;UAAA,IAA5BC,eAAA,GAAAJ,KAAA,CAAAK,KAAA;UACT,IAAMC,aAAA,GAAgBb,UAAA,CAAWc,GAAA,CAAIH,eAAA,CAAgBI,SAAS;UAE9D,IAAI,CAACF,aAAA,EAAe;YAClBV,UAAA,CAAWa,IAAA,CAAKL,eAAe;UACjC,OAAO;YACL,IAAMM,gBAAA,GACJN,eAAA,CAAgBnB,KAAA,CAAM0B,aAAA,GACpBL,aAAA,CAAcrB,KAAA,CAAM0B,aAAA,IACrBP,eAAA,CAAgBQ,OAAA,IACfN,aAAA,CAAcrB,KAAA,CAAM4B,MAAA,KAAW,aAC/BP,aAAA,CAAcrB,KAAA,CAAM6B,WAAA,KAAgB,cACpCV,eAAA,CAAgBW,YAAA,KAAiB,UACjCX,eAAA,CAAgBW,YAAA,GACdT,aAAA,CAAcrB,KAAA,CAAM0B,aAAA;YAE1B,IAAID,gBAAA,EAAkB;cACpBb,eAAA,CAAgBY,IAAA,CAAKL,eAAe;YACtC;UACF;QACF;MAAA,SAAAY,GAAA;QAAAlB,SAAA,CAAAmB,CAAA,CAAAD,GAAA;MAAA;QAAAlB,SAAA,CAAAoB,CAAA;MAAA;MAEA,IAAItB,UAAA,CAAWuB,MAAA,GAAS,GAAG;QAGzBzC,OAAA,CAAQS,MAAA,EAAQ;UAAEQ,OAAA,EAASC;QAAW,GAAGR,UAAA,CAAWE,OAAO;MAC7D;MACA,IAAIO,eAAA,CAAgBsB,MAAA,GAAS,GAAG;QAC9B,OAAOtB,eAAA;MACT;IACF;IACA,OAAO;EACT,GAAG,CAACV,MAAA,EAAQF,KAAK,CAAC;EAEdR,KAAA,CAAA2C,SAAA,CAAU,YAAM;IACpB,IAAI7B,cAAA,EAAgB;MAClBb,OAAA,CAAQS,MAAA,EAAQ;QAAEQ,OAAA,EAASJ;MAAe,GAAGH,UAAA,CAAWE,OAAO;IACjE;EACF,GAAG,CAACH,MAAA,EAAQI,cAAc,CAAC;EAE3B,OAAOT,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}