{"ast":null,"code":"import _slicedToArray from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport var JSONSchemaGenerator = /*#__PURE__*/function () {\n  function JSONSchemaGenerator(params) {\n    var _params$metadata, _params$target, _params$unrepresentab, _params$override, _params$io;\n    _classCallCheck(this, JSONSchemaGenerator);\n    this.counter = 0;\n    this.metadataRegistry = (_params$metadata = params === null || params === void 0 ? void 0 : params.metadata) !== null && _params$metadata !== void 0 ? _params$metadata : globalRegistry;\n    this.target = (_params$target = params === null || params === void 0 ? void 0 : params.target) !== null && _params$target !== void 0 ? _params$target : \"draft-2020-12\";\n    this.unrepresentable = (_params$unrepresentab = params === null || params === void 0 ? void 0 : params.unrepresentable) !== null && _params$unrepresentab !== void 0 ? _params$unrepresentab : \"throw\";\n    this.override = (_params$override = params === null || params === void 0 ? void 0 : params.override) !== null && _params$override !== void 0 ? _params$override : function () {};\n    this.io = (_params$io = params === null || params === void 0 ? void 0 : params.io) !== null && _params$io !== void 0 ? _params$io : \"output\";\n    this.seen = new Map();\n  }\n  return _createClass(JSONSchemaGenerator, [{\n    key: \"process\",\n    value: function process(schema) {\n      var _schema$_zod$toJSONSc,\n        _schema$_zod,\n        _this = this,\n        _a$default;\n      var _params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        path: [],\n        schemaPath: []\n      };\n      var _a;\n      var def = schema._zod.def;\n      var formatMap = {\n        guid: \"uuid\",\n        url: \"uri\",\n        datetime: \"date-time\",\n        json_string: \"json-string\",\n        regex: \"\" // do not set\n      };\n      // check for schema in seens\n      var seen = this.seen.get(schema);\n      if (seen) {\n        seen.count++;\n        // check if cycle\n        var isCycle = _params.schemaPath.includes(schema);\n        if (isCycle) {\n          seen.cycle = _params.path;\n        }\n        return seen.schema;\n      }\n      // initialize\n      var result = {\n        schema: {},\n        count: 1,\n        cycle: undefined\n      };\n      this.seen.set(schema, result);\n      // custom method overrides default behavior\n      var overrideSchema = (_schema$_zod$toJSONSc = (_schema$_zod = schema._zod).toJSONSchema) === null || _schema$_zod$toJSONSc === void 0 ? void 0 : _schema$_zod$toJSONSc.call(_schema$_zod);\n      if (overrideSchema) {\n        result.schema = overrideSchema;\n      } else {\n        var params = _objectSpread(_objectSpread({}, _params), {}, {\n          schemaPath: [].concat(_toConsumableArray(_params.schemaPath), [schema]),\n          path: _params.path\n        });\n        var parent = schema._zod.parent;\n        if (parent) {\n          // schema was cloned from another schema\n          result.ref = parent;\n          this.process(parent, params);\n          this.seen.get(parent).isParent = true;\n        } else {\n          var _json = result.schema;\n          switch (def.type) {\n            case \"string\":\n              {\n                var json = _json;\n                json.type = \"string\";\n                var _schema$_zod$bag = schema._zod.bag,\n                  minimum = _schema$_zod$bag.minimum,\n                  maximum = _schema$_zod$bag.maximum,\n                  format = _schema$_zod$bag.format,\n                  patterns = _schema$_zod$bag.patterns,\n                  contentEncoding = _schema$_zod$bag.contentEncoding;\n                if (typeof minimum === \"number\") json.minLength = minimum;\n                if (typeof maximum === \"number\") json.maxLength = maximum;\n                // custom pattern overrides format\n                if (format) {\n                  var _formatMap$format;\n                  json.format = (_formatMap$format = formatMap[format]) !== null && _formatMap$format !== void 0 ? _formatMap$format : format;\n                  if (json.format === \"\") delete json.format; // empty format is not valid\n                }\n                if (contentEncoding) json.contentEncoding = contentEncoding;\n                if (patterns && patterns.size > 0) {\n                  var regexes = _toConsumableArray(patterns);\n                  if (regexes.length === 1) json.pattern = regexes[0].source;else if (regexes.length > 1) {\n                    result.schema.allOf = _toConsumableArray(regexes.map(function (regex) {\n                      return _objectSpread(_objectSpread({}, _this.target === \"draft-7\" ? {\n                        type: \"string\"\n                      } : {}), {}, {\n                        pattern: regex.source\n                      });\n                    }));\n                  }\n                }\n                break;\n              }\n            case \"number\":\n              {\n                var _json2 = _json;\n                var _schema$_zod$bag2 = schema._zod.bag,\n                  _minimum = _schema$_zod$bag2.minimum,\n                  _maximum = _schema$_zod$bag2.maximum,\n                  _format = _schema$_zod$bag2.format,\n                  multipleOf = _schema$_zod$bag2.multipleOf,\n                  exclusiveMaximum = _schema$_zod$bag2.exclusiveMaximum,\n                  exclusiveMinimum = _schema$_zod$bag2.exclusiveMinimum;\n                if (typeof _format === \"string\" && _format.includes(\"int\")) _json2.type = \"integer\";else _json2.type = \"number\";\n                if (typeof exclusiveMinimum === \"number\") _json2.exclusiveMinimum = exclusiveMinimum;\n                if (typeof _minimum === \"number\") {\n                  _json2.minimum = _minimum;\n                  if (typeof exclusiveMinimum === \"number\") {\n                    if (exclusiveMinimum >= _minimum) delete _json2.minimum;else delete _json2.exclusiveMinimum;\n                  }\n                }\n                if (typeof exclusiveMaximum === \"number\") _json2.exclusiveMaximum = exclusiveMaximum;\n                if (typeof _maximum === \"number\") {\n                  _json2.maximum = _maximum;\n                  if (typeof exclusiveMaximum === \"number\") {\n                    if (exclusiveMaximum <= _maximum) delete _json2.maximum;else delete _json2.exclusiveMaximum;\n                  }\n                }\n                if (typeof multipleOf === \"number\") _json2.multipleOf = multipleOf;\n                break;\n              }\n            case \"boolean\":\n              {\n                var _json3 = _json;\n                _json3.type = \"boolean\";\n                break;\n              }\n            case \"bigint\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"symbol\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"undefined\":\n              {\n                var _json4 = _json;\n                _json4.type = \"null\";\n                break;\n              }\n            case \"null\":\n              {\n                _json.type = \"null\";\n                break;\n              }\n            case \"any\":\n              {\n                break;\n              }\n            case \"unknown\":\n              {\n                break;\n              }\n            case \"never\":\n              {\n                _json.not = {};\n                break;\n              }\n            case \"void\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Void cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"date\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Date cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"array\":\n              {\n                var _json5 = _json;\n                var _schema$_zod$bag3 = schema._zod.bag,\n                  _minimum2 = _schema$_zod$bag3.minimum,\n                  _maximum2 = _schema$_zod$bag3.maximum;\n                if (typeof _minimum2 === \"number\") _json5.minItems = _minimum2;\n                if (typeof _maximum2 === \"number\") _json5.maxItems = _maximum2;\n                _json5.type = \"array\";\n                _json5.items = this.process(def.element, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [].concat(_toConsumableArray(params.path), [\"items\"])\n                }));\n                break;\n              }\n            case \"object\":\n              {\n                var _def$catchall;\n                var _json6 = _json;\n                _json6.type = \"object\";\n                _json6.properties = {};\n                var shape = def.shape; // params.shapeCache.get(schema)!;\n                for (var key in shape) {\n                  _json6.properties[key] = this.process(shape[key], _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"properties\", key])\n                  }));\n                }\n                // required keys\n                var allKeys = new Set(Object.keys(shape));\n                // const optionalKeys = new Set(def.optional);\n                var requiredKeys = new Set(_toConsumableArray(allKeys).filter(function (key) {\n                  var v = def.shape[key]._zod;\n                  if (_this.io === \"input\") {\n                    return v.optin === undefined;\n                  } else {\n                    return v.optout === undefined;\n                  }\n                }));\n                if (requiredKeys.size > 0) {\n                  _json6.required = Array.from(requiredKeys);\n                }\n                // catchall\n                if (((_def$catchall = def.catchall) === null || _def$catchall === void 0 ? void 0 : _def$catchall._zod.def.type) === \"never\") {\n                  // strict\n                  _json6.additionalProperties = false;\n                } else if (!def.catchall) {\n                  // regular\n                  if (this.io === \"output\") _json6.additionalProperties = false;\n                } else if (def.catchall) {\n                  _json6.additionalProperties = this.process(def.catchall, _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"additionalProperties\"])\n                  }));\n                }\n                break;\n              }\n            case \"union\":\n              {\n                var _json7 = _json;\n                _json7.anyOf = def.options.map(function (x, i) {\n                  return _this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"anyOf\", i])\n                  }));\n                });\n                break;\n              }\n            case \"intersection\":\n              {\n                var _json8 = _json;\n                var a = this.process(def.left, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [].concat(_toConsumableArray(params.path), [\"allOf\", 0])\n                }));\n                var b = this.process(def.right, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [].concat(_toConsumableArray(params.path), [\"allOf\", 1])\n                }));\n                var isSimpleIntersection = function isSimpleIntersection(val) {\n                  return \"allOf\" in val && Object.keys(val).length === 1;\n                };\n                var allOf = [].concat(_toConsumableArray(isSimpleIntersection(a) ? a.allOf : [a]), _toConsumableArray(isSimpleIntersection(b) ? b.allOf : [b]));\n                _json8.allOf = allOf;\n                break;\n              }\n            case \"tuple\":\n              {\n                var _json9 = _json;\n                _json9.type = \"array\";\n                var prefixItems = def.items.map(function (x, i) {\n                  return _this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"prefixItems\", i])\n                  }));\n                });\n                if (this.target === \"draft-2020-12\") {\n                  _json9.prefixItems = prefixItems;\n                } else {\n                  _json9.items = prefixItems;\n                }\n                if (def.rest) {\n                  var rest = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"items\"])\n                  }));\n                  if (this.target === \"draft-2020-12\") {\n                    _json9.items = rest;\n                  } else {\n                    _json9.additionalItems = rest;\n                  }\n                }\n                // additionalItems\n                if (def.rest) {\n                  _json9.items = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                    path: [].concat(_toConsumableArray(params.path), [\"items\"])\n                  }));\n                }\n                // length\n                var _schema$_zod$bag4 = schema._zod.bag,\n                  _minimum3 = _schema$_zod$bag4.minimum,\n                  _maximum3 = _schema$_zod$bag4.maximum;\n                if (typeof _minimum3 === \"number\") _json9.minItems = _minimum3;\n                if (typeof _maximum3 === \"number\") _json9.maxItems = _maximum3;\n                break;\n              }\n            case \"record\":\n              {\n                var _json0 = _json;\n                _json0.type = \"object\";\n                _json0.propertyNames = this.process(def.keyType, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [].concat(_toConsumableArray(params.path), [\"propertyNames\"])\n                }));\n                _json0.additionalProperties = this.process(def.valueType, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [].concat(_toConsumableArray(params.path), [\"additionalProperties\"])\n                }));\n                break;\n              }\n            case \"map\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Map cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"set\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Set cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"enum\":\n              {\n                var _json1 = _json;\n                var values = getEnumValues(def.entries);\n                // Number enums can have both string and number values\n                if (values.every(function (v) {\n                  return typeof v === \"number\";\n                })) _json1.type = \"number\";\n                if (values.every(function (v) {\n                  return typeof v === \"string\";\n                })) _json1.type = \"string\";\n                _json1.enum = values;\n                break;\n              }\n            case \"literal\":\n              {\n                var _json10 = _json;\n                var vals = [];\n                var _iterator = _createForOfIteratorHelper(def.values),\n                  _step;\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var _val = _step.value;\n                    if (_val === undefined) {\n                      if (this.unrepresentable === \"throw\") {\n                        throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                      } else {\n                        // do not add to vals\n                      }\n                    } else if (typeof _val === \"bigint\") {\n                      if (this.unrepresentable === \"throw\") {\n                        throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                      } else {\n                        vals.push(Number(_val));\n                      }\n                    } else {\n                      vals.push(_val);\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                if (vals.length === 0) {\n                  // do nothing (an undefined literal was stripped)\n                } else if (vals.length === 1) {\n                  var val = vals[0];\n                  _json10.type = val === null ? \"null\" : typeof val;\n                  _json10.const = val;\n                } else {\n                  if (vals.every(function (v) {\n                    return typeof v === \"number\";\n                  })) _json10.type = \"number\";\n                  if (vals.every(function (v) {\n                    return typeof v === \"string\";\n                  })) _json10.type = \"string\";\n                  if (vals.every(function (v) {\n                    return typeof v === \"boolean\";\n                  })) _json10.type = \"string\";\n                  if (vals.every(function (v) {\n                    return v === null;\n                  })) _json10.type = \"null\";\n                  _json10.enum = vals;\n                }\n                break;\n              }\n            case \"file\":\n              {\n                var _json11 = _json;\n                var file = {\n                  type: \"string\",\n                  format: \"binary\",\n                  contentEncoding: \"binary\"\n                };\n                var _schema$_zod$bag5 = schema._zod.bag,\n                  _minimum4 = _schema$_zod$bag5.minimum,\n                  _maximum4 = _schema$_zod$bag5.maximum,\n                  mime = _schema$_zod$bag5.mime;\n                if (_minimum4 !== undefined) file.minLength = _minimum4;\n                if (_maximum4 !== undefined) file.maxLength = _maximum4;\n                if (mime) {\n                  if (mime.length === 1) {\n                    file.contentMediaType = mime[0];\n                    Object.assign(_json11, file);\n                  } else {\n                    _json11.anyOf = mime.map(function (m) {\n                      var mFile = _objectSpread(_objectSpread({}, file), {}, {\n                        contentMediaType: m\n                      });\n                      return mFile;\n                    });\n                  }\n                } else {\n                  Object.assign(_json11, file);\n                }\n                // if (this.unrepresentable === \"throw\") {\n                //   throw new Error(\"File cannot be represented in JSON Schema\");\n                // }\n                break;\n              }\n            case \"transform\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"nullable\":\n              {\n                var inner = this.process(def.innerType, params);\n                _json.anyOf = [inner, {\n                  type: \"null\"\n                }];\n                break;\n              }\n            case \"nonoptional\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                break;\n              }\n            case \"success\":\n              {\n                var _json12 = _json;\n                _json12.type = \"boolean\";\n                break;\n              }\n            case \"default\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                break;\n              }\n            case \"prefault\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                break;\n              }\n            case \"catch\":\n              {\n                // use conditionals\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                var catchValue;\n                try {\n                  catchValue = def.catchValue(undefined);\n                } catch (_unused) {\n                  throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                }\n                _json.default = catchValue;\n                break;\n              }\n            case \"nan\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"NaN cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            case \"template_literal\":\n              {\n                var _json13 = _json;\n                var pattern = schema._zod.pattern;\n                if (!pattern) throw new Error(\"Pattern not found in template literal\");\n                _json13.type = \"string\";\n                _json13.pattern = pattern.source;\n                break;\n              }\n            case \"pipe\":\n              {\n                var innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n                this.process(innerType, params);\n                result.ref = innerType;\n                break;\n              }\n            case \"readonly\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                _json.readOnly = true;\n                break;\n              }\n            // passthrough types\n            case \"promise\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                break;\n              }\n            case \"optional\":\n              {\n                this.process(def.innerType, params);\n                result.ref = def.innerType;\n                break;\n              }\n            case \"lazy\":\n              {\n                var _innerType = schema._zod.innerType;\n                this.process(_innerType, params);\n                result.ref = _innerType;\n                break;\n              }\n            case \"custom\":\n              {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                }\n                break;\n              }\n            default:\n              {\n                def;\n              }\n          }\n        }\n      }\n      // metadata\n      var meta = this.metadataRegistry.get(schema);\n      if (meta) Object.assign(result.schema, meta);\n      if (this.io === \"input\" && isTransforming(schema)) {\n        // examples/defaults only apply to output type of pipe\n        delete result.schema.examples;\n        delete result.schema.default;\n      }\n      // set prefault as default\n      if (this.io === \"input\" && result.schema._prefault) (_a$default = (_a = result.schema).default) !== null && _a$default !== void 0 ? _a$default : _a.default = result.schema._prefault;\n      delete result.schema._prefault;\n      // pulling fresh from this.seen in case it was overwritten\n      var _result = this.seen.get(schema);\n      return _result.schema;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(schema, _params) {\n      var _params$cycles,\n        _params$reused,\n        _params$external,\n        _this2 = this,\n        _params$external$defs,\n        _params$external2;\n      var params = {\n        cycles: (_params$cycles = _params === null || _params === void 0 ? void 0 : _params.cycles) !== null && _params$cycles !== void 0 ? _params$cycles : \"ref\",\n        reused: (_params$reused = _params === null || _params === void 0 ? void 0 : _params.reused) !== null && _params$reused !== void 0 ? _params$reused : \"inline\",\n        // unrepresentable: _params?.unrepresentable ?? \"throw\",\n        // uri: _params?.uri ?? ((id) => `${id}`),\n        external: (_params$external = _params === null || _params === void 0 ? void 0 : _params.external) !== null && _params$external !== void 0 ? _params$external : undefined\n      };\n      // iterate over seen map;\n      var root = this.seen.get(schema);\n      if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n      // initialize result with root schema fields\n      // Object.assign(result, seen.cached);\n      var makeURI = function makeURI(entry) {\n        var _entry$1$schema$id;\n        // comparing the seen objects because sometimes\n        // multiple schemas map to the same seen object.\n        // e.g. lazy\n        // external is configured\n        var defsSegment = _this2.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n        if (params.external) {\n          var _params$external$regi, _ref, _entry$1$defId;\n          var externalId = (_params$external$regi = params.external.registry.get(entry[0])) === null || _params$external$regi === void 0 ? void 0 : _params$external$regi.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n          // check if schema is in the external registry\n          if (externalId) return {\n            ref: params.external.uri(externalId)\n          };\n          // otherwise, add to __shared\n          var id = (_ref = (_entry$1$defId = entry[1].defId) !== null && _entry$1$defId !== void 0 ? _entry$1$defId : entry[1].schema.id) !== null && _ref !== void 0 ? _ref : \"schema\".concat(_this2.counter++);\n          entry[1].defId = id;\n          return {\n            defId: id,\n            ref: \"\".concat(params.external.uri(\"__shared\"), \"#/\").concat(defsSegment, \"/\").concat(id)\n          };\n        }\n        if (entry[1] === root) {\n          return {\n            ref: \"#\"\n          };\n        }\n        // self-contained schema\n        var uriPrefix = \"#\";\n        var defUriPrefix = \"\".concat(uriPrefix, \"/\").concat(defsSegment, \"/\");\n        var defId = (_entry$1$schema$id = entry[1].schema.id) !== null && _entry$1$schema$id !== void 0 ? _entry$1$schema$id : \"__schema\".concat(_this2.counter++);\n        return {\n          defId: defId,\n          ref: defUriPrefix + defId\n        };\n      };\n      // stored cached version in `def` property\n      // remove all properties, set $ref\n      var extractToDef = function extractToDef(entry) {\n        if (entry[1].schema.$ref) {\n          return;\n        }\n        var seen = entry[1];\n        var _makeURI = makeURI(entry),\n          ref = _makeURI.ref,\n          defId = _makeURI.defId;\n        seen.def = _objectSpread({}, seen.schema);\n        // defId won't be set if the schema is a reference to an external schema\n        if (defId) seen.defId = defId;\n        // wipe away all properties except $ref\n        var schema = seen.schema;\n        for (var key in schema) {\n          delete schema[key];\n        }\n        schema.$ref = ref;\n      };\n      // extract schemas into $defs\n      var _iterator2 = _createForOfIteratorHelper(this.seen.entries()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$metadataRegistr;\n          var entry = _step2.value;\n          var seen = entry[1];\n          // convert root schema to # $ref\n          // also prevents root schema from being extracted\n          if (schema === entry[0]) {\n            // do not copy to defs...this is the root schema\n            extractToDef(entry);\n            continue;\n          }\n          // extract schemas that are in the external registry\n          if (params.external) {\n            var _params$external$regi2;\n            var ext = (_params$external$regi2 = params.external.registry.get(entry[0])) === null || _params$external$regi2 === void 0 ? void 0 : _params$external$regi2.id;\n            if (schema !== entry[0] && ext) {\n              extractToDef(entry);\n              continue;\n            }\n          }\n          // extract schemas with `id` meta\n          var id = (_this$metadataRegistr = this.metadataRegistry.get(entry[0])) === null || _this$metadataRegistr === void 0 ? void 0 : _this$metadataRegistr.id;\n          if (id) {\n            extractToDef(entry);\n            continue;\n          }\n          // break cycles\n          if (seen.cycle) {\n            if (params.cycles === \"throw\") {\n              var _seen$cycle;\n              throw new Error(\"Cycle detected: \" + \"#/\".concat((_seen$cycle = seen.cycle) === null || _seen$cycle === void 0 ? void 0 : _seen$cycle.join(\"/\"), \"/<root>\") + '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n            } else if (params.cycles === \"ref\") {\n              extractToDef(entry);\n            }\n            continue;\n          }\n          // extract reused schemas\n          if (seen.count > 1) {\n            if (params.reused === \"ref\") {\n              extractToDef(entry);\n              // biome-ignore lint:\n              continue;\n            }\n          }\n        }\n        // flatten _refs\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _flattenRef = function flattenRef(zodSchema, params) {\n        var _seen$def;\n        var seen = _this2.seen.get(zodSchema);\n        var schema = (_seen$def = seen.def) !== null && _seen$def !== void 0 ? _seen$def : seen.schema;\n        var _cached = _objectSpread({}, schema);\n        // already seen\n        if (seen.ref === null) {\n          return;\n        }\n        // flatten ref if defined\n        var ref = seen.ref;\n        seen.ref = null; // prevent recursion\n        if (ref) {\n          _flattenRef(ref, params);\n          // merge referenced schema into current\n          var refSchema = _this2.seen.get(ref).schema;\n          if (refSchema.$ref && params.target === \"draft-7\") {\n            var _schema$allOf;\n            schema.allOf = (_schema$allOf = schema.allOf) !== null && _schema$allOf !== void 0 ? _schema$allOf : [];\n            schema.allOf.push(refSchema);\n          } else {\n            Object.assign(schema, refSchema);\n            Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n          }\n        }\n        // execute overrides\n        if (!seen.isParent) _this2.override({\n          zodSchema: zodSchema,\n          jsonSchema: schema\n        });\n      };\n      var _iterator3 = _createForOfIteratorHelper(_toConsumableArray(this.seen.entries()).reverse()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _entry = _step3.value;\n          _flattenRef(_entry[0], {\n            target: this.target\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var result = {};\n      if (this.target === \"draft-2020-12\") {\n        result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n      } else if (this.target === \"draft-7\") {\n        result.$schema = \"http://json-schema.org/draft-07/schema#\";\n      } else {\n        console.warn(\"Invalid target: \".concat(this.target));\n      }\n      Object.assign(result, root.def);\n      // build defs object\n      var defs = (_params$external$defs = (_params$external2 = params.external) === null || _params$external2 === void 0 ? void 0 : _params$external2.defs) !== null && _params$external$defs !== void 0 ? _params$external$defs : {};\n      var _iterator4 = _createForOfIteratorHelper(this.seen.entries()),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _entry2 = _step4.value;\n          var _seen = _entry2[1];\n          if (_seen.def && _seen.defId) {\n            defs[_seen.defId] = _seen.def;\n          }\n        }\n        // set definitions in result\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (!params.external && Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n      try {\n        // this \"finalizes\" this schema and ensures all cycles are removed\n        // each call to .emit() is functionally independent\n        // though the seen map is shared\n        return JSON.parse(JSON.stringify(result));\n      } catch (_err) {\n        throw new Error(\"Error converting schema to JSON.\");\n      }\n    }\n  }]);\n}();\nexport function toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    var _gen = new JSONSchemaGenerator(_params);\n    var defs = {};\n    var _iterator5 = _createForOfIteratorHelper(input._idmap.entries()),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var entry = _step5.value;\n        var _entry3 = _slicedToArray(entry, 2),\n          _ = _entry3[0],\n          schema = _entry3[1];\n        _gen.process(schema);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    var schemas = {};\n    var external = {\n      registry: input,\n      uri: (_params === null || _params === void 0 ? void 0 : _params.uri) || function (id) {\n        return id;\n      },\n      defs: defs\n    };\n    var _iterator6 = _createForOfIteratorHelper(input._idmap.entries()),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _entry4 = _step6.value;\n        var _entry5 = _slicedToArray(_entry4, 2),\n          key = _entry5[0],\n          _schema2 = _entry5[1];\n        schemas[key] = _gen.emit(_schema2, _objectSpread(_objectSpread({}, _params), {}, {\n          external: external\n        }));\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    if (Object.keys(defs).length > 0) {\n      var defsSegment = _gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = _defineProperty({}, defsSegment, defs);\n    }\n    return {\n      schemas: schemas\n    };\n  }\n  var gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  var ctx = _ctx !== null && _ctx !== void 0 ? _ctx : {\n    seen: new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  var schema = _schema;\n  var def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (var key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        var _iterator7 = _createForOfIteratorHelper(def.options),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var option = _step7.value;\n            if (isTransforming(option, ctx)) return true;\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        var _iterator8 = _createForOfIteratorHelper(def.items),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var item = _step8.value;\n            if (isTransforming(item, ctx)) return true;\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(\"Unknown schema type: \".concat(def.type));\n}","map":{"version":3,"names":["$ZodRegistry","globalRegistry","getEnumValues","JSONSchemaGenerator","params","_params$metadata","_params$target","_params$unrepresentab","_params$override","_params$io","_classCallCheck","counter","metadataRegistry","metadata","target","unrepresentable","override","io","seen","Map","_createClass","key","value","process","schema","_schema$_zod$toJSONSc","_schema$_zod","_this","_a$default","_params","arguments","length","undefined","path","schemaPath","_a","def","_zod","formatMap","guid","url","datetime","json_string","regex","get","count","isCycle","includes","cycle","result","set","overrideSchema","toJSONSchema","call","_objectSpread","concat","_toConsumableArray","parent","ref","isParent","_json","type","json","_schema$_zod$bag","bag","minimum","maximum","format","patterns","contentEncoding","minLength","maxLength","_formatMap$format","size","regexes","pattern","source","allOf","map","_schema$_zod$bag2","multipleOf","exclusiveMaximum","exclusiveMinimum","Error","not","_schema$_zod$bag3","minItems","maxItems","items","element","_def$catchall","properties","shape","allKeys","Set","Object","keys","requiredKeys","filter","v","optin","optout","required","Array","from","catchall","additionalProperties","anyOf","options","x","i","a","left","b","right","isSimpleIntersection","val","prefixItems","rest","additionalItems","_schema$_zod$bag4","propertyNames","keyType","valueType","values","entries","every","enum","vals","_iterator","_createForOfIteratorHelper","_step","s","n","done","push","Number","err","e","f","const","file","_schema$_zod$bag5","mime","contentMediaType","assign","m","mFile","inner","innerType","default","JSON","parse","stringify","defaultValue","_prefault","catchValue","_unused","in","out","readOnly","meta","isTransforming","examples","_result","emit","_params$cycles","_params$reused","_params$external","_this2","_params$external$defs","_params$external2","cycles","reused","external","root","makeURI","entry","_entry$1$schema$id","defsSegment","_params$external$regi","_ref","_entry$1$defId","externalId","registry","id","uri","defId","uriPrefix","defUriPrefix","extractToDef","$ref","_makeURI","_iterator2","_step2","_this$metadataRegistr","_params$external$regi2","ext","_seen$cycle","join","flattenRef","zodSchema","_seen$def","_cached","refSchema","_schema$allOf","jsonSchema","_iterator3","reverse","_step3","$schema","console","warn","defs","_iterator4","_step4","$defs","definitions","_err","input","gen","_iterator5","_idmap","_step5","_entry3","_slicedToArray","_","schemas","_iterator6","_step6","_entry5","__shared","_defineProperty","_schema","_ctx","ctx","has","add","_iterator7","_step7","option","_iterator8","_step8","item","getter"],"sources":["C:/Users/als40/Desktop/HandsMarket/node_modules/zod/dist/esm/v4/core/to-json-schema.js"],"sourcesContent":["import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n    constructor(params) {\n        this.counter = 0;\n        this.metadataRegistry = params?.metadata ?? globalRegistry;\n        this.target = params?.target ?? \"draft-2020-12\";\n        this.unrepresentable = params?.unrepresentable ?? \"throw\";\n        this.override = params?.override ?? (() => { });\n        this.io = params?.io ?? \"output\";\n        this.seen = new Map();\n    }\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        var _a;\n        const def = schema._zod.def;\n        const formatMap = {\n            guid: \"uuid\",\n            url: \"uri\",\n            datetime: \"date-time\",\n            json_string: \"json-string\",\n            regex: \"\", // do not set\n        };\n        // check for schema in seens\n        const seen = this.seen.get(schema);\n        if (seen) {\n            seen.count++;\n            // check if cycle\n            const isCycle = _params.schemaPath.includes(schema);\n            if (isCycle) {\n                seen.cycle = _params.path;\n            }\n            return seen.schema;\n        }\n        // initialize\n        const result = { schema: {}, count: 1, cycle: undefined };\n        this.seen.set(schema, result);\n        // custom method overrides default behavior\n        const overrideSchema = schema._zod.toJSONSchema?.();\n        if (overrideSchema) {\n            result.schema = overrideSchema;\n        }\n        else {\n            const params = {\n                ..._params,\n                schemaPath: [..._params.schemaPath, schema],\n                path: _params.path,\n            };\n            const parent = schema._zod.parent;\n            if (parent) {\n                // schema was cloned from another schema\n                result.ref = parent;\n                this.process(parent, params);\n                this.seen.get(parent).isParent = true;\n            }\n            else {\n                const _json = result.schema;\n                switch (def.type) {\n                    case \"string\": {\n                        const json = _json;\n                        json.type = \"string\";\n                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n                            .bag;\n                        if (typeof minimum === \"number\")\n                            json.minLength = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxLength = maximum;\n                        // custom pattern overrides format\n                        if (format) {\n                            json.format = formatMap[format] ?? format;\n                            if (json.format === \"\")\n                                delete json.format; // empty format is not valid\n                        }\n                        if (contentEncoding)\n                            json.contentEncoding = contentEncoding;\n                        if (patterns && patterns.size > 0) {\n                            const regexes = [...patterns];\n                            if (regexes.length === 1)\n                                json.pattern = regexes[0].source;\n                            else if (regexes.length > 1) {\n                                result.schema.allOf = [\n                                    ...regexes.map((regex) => ({\n                                        ...(this.target === \"draft-7\" ? { type: \"string\" } : {}),\n                                        pattern: regex.source,\n                                    })),\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case \"number\": {\n                        const json = _json;\n                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n                        if (typeof format === \"string\" && format.includes(\"int\"))\n                            json.type = \"integer\";\n                        else\n                            json.type = \"number\";\n                        if (typeof exclusiveMinimum === \"number\")\n                            json.exclusiveMinimum = exclusiveMinimum;\n                        if (typeof minimum === \"number\") {\n                            json.minimum = minimum;\n                            if (typeof exclusiveMinimum === \"number\") {\n                                if (exclusiveMinimum >= minimum)\n                                    delete json.minimum;\n                                else\n                                    delete json.exclusiveMinimum;\n                            }\n                        }\n                        if (typeof exclusiveMaximum === \"number\")\n                            json.exclusiveMaximum = exclusiveMaximum;\n                        if (typeof maximum === \"number\") {\n                            json.maximum = maximum;\n                            if (typeof exclusiveMaximum === \"number\") {\n                                if (exclusiveMaximum <= maximum)\n                                    delete json.maximum;\n                                else\n                                    delete json.exclusiveMaximum;\n                            }\n                        }\n                        if (typeof multipleOf === \"number\")\n                            json.multipleOf = multipleOf;\n                        break;\n                    }\n                    case \"boolean\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"bigint\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"symbol\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"undefined\": {\n                        const json = _json;\n                        json.type = \"null\";\n                        break;\n                    }\n                    case \"null\": {\n                        _json.type = \"null\";\n                        break;\n                    }\n                    case \"any\": {\n                        break;\n                    }\n                    case \"unknown\": {\n                        break;\n                    }\n                    case \"never\": {\n                        _json.not = {};\n                        break;\n                    }\n                    case \"void\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Void cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"date\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Date cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"array\": {\n                        const json = _json;\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        json.type = \"array\";\n                        json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n                        break;\n                    }\n                    case \"object\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.properties = {};\n                        const shape = def.shape; // params.shapeCache.get(schema)!;\n                        for (const key in shape) {\n                            json.properties[key] = this.process(shape[key], {\n                                ...params,\n                                path: [...params.path, \"properties\", key],\n                            });\n                        }\n                        // required keys\n                        const allKeys = new Set(Object.keys(shape));\n                        // const optionalKeys = new Set(def.optional);\n                        const requiredKeys = new Set([...allKeys].filter((key) => {\n                            const v = def.shape[key]._zod;\n                            if (this.io === \"input\") {\n                                return v.optin === undefined;\n                            }\n                            else {\n                                return v.optout === undefined;\n                            }\n                        }));\n                        if (requiredKeys.size > 0) {\n                            json.required = Array.from(requiredKeys);\n                        }\n                        // catchall\n                        if (def.catchall?._zod.def.type === \"never\") {\n                            // strict\n                            json.additionalProperties = false;\n                        }\n                        else if (!def.catchall) {\n                            // regular\n                            if (this.io === \"output\")\n                                json.additionalProperties = false;\n                        }\n                        else if (def.catchall) {\n                            json.additionalProperties = this.process(def.catchall, {\n                                ...params,\n                                path: [...params.path, \"additionalProperties\"],\n                            });\n                        }\n                        break;\n                    }\n                    case \"union\": {\n                        const json = _json;\n                        json.anyOf = def.options.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, \"anyOf\", i],\n                        }));\n                        break;\n                    }\n                    case \"intersection\": {\n                        const json = _json;\n                        const a = this.process(def.left, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 0],\n                        });\n                        const b = this.process(def.right, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 1],\n                        });\n                        const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n                        const allOf = [\n                            ...(isSimpleIntersection(a) ? a.allOf : [a]),\n                            ...(isSimpleIntersection(b) ? b.allOf : [b]),\n                        ];\n                        json.allOf = allOf;\n                        break;\n                    }\n                    case \"tuple\": {\n                        const json = _json;\n                        json.type = \"array\";\n                        const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] }));\n                        if (this.target === \"draft-2020-12\") {\n                            json.prefixItems = prefixItems;\n                        }\n                        else {\n                            json.items = prefixItems;\n                        }\n                        if (def.rest) {\n                            const rest = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                            if (this.target === \"draft-2020-12\") {\n                                json.items = rest;\n                            }\n                            else {\n                                json.additionalItems = rest;\n                            }\n                        }\n                        // additionalItems\n                        if (def.rest) {\n                            json.items = this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, \"items\"],\n                            });\n                        }\n                        // length\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        break;\n                    }\n                    case \"record\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n                        json.additionalProperties = this.process(def.valueType, {\n                            ...params,\n                            path: [...params.path, \"additionalProperties\"],\n                        });\n                        break;\n                    }\n                    case \"map\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Map cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"set\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Set cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"enum\": {\n                        const json = _json;\n                        const values = getEnumValues(def.entries);\n                        // Number enums can have both string and number values\n                        if (values.every((v) => typeof v === \"number\"))\n                            json.type = \"number\";\n                        if (values.every((v) => typeof v === \"string\"))\n                            json.type = \"string\";\n                        json.enum = values;\n                        break;\n                    }\n                    case \"literal\": {\n                        const json = _json;\n                        const vals = [];\n                        for (const val of def.values) {\n                            if (val === undefined) {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    // do not add to vals\n                                }\n                            }\n                            else if (typeof val === \"bigint\") {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    vals.push(Number(val));\n                                }\n                            }\n                            else {\n                                vals.push(val);\n                            }\n                        }\n                        if (vals.length === 0) {\n                            // do nothing (an undefined literal was stripped)\n                        }\n                        else if (vals.length === 1) {\n                            const val = vals[0];\n                            json.type = val === null ? \"null\" : typeof val;\n                            json.const = val;\n                        }\n                        else {\n                            if (vals.every((v) => typeof v === \"number\"))\n                                json.type = \"number\";\n                            if (vals.every((v) => typeof v === \"string\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => typeof v === \"boolean\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => v === null))\n                                json.type = \"null\";\n                            json.enum = vals;\n                        }\n                        break;\n                    }\n                    case \"file\": {\n                        const json = _json;\n                        const file = {\n                            type: \"string\",\n                            format: \"binary\",\n                            contentEncoding: \"binary\",\n                        };\n                        const { minimum, maximum, mime } = schema._zod.bag;\n                        if (minimum !== undefined)\n                            file.minLength = minimum;\n                        if (maximum !== undefined)\n                            file.maxLength = maximum;\n                        if (mime) {\n                            if (mime.length === 1) {\n                                file.contentMediaType = mime[0];\n                                Object.assign(json, file);\n                            }\n                            else {\n                                json.anyOf = mime.map((m) => {\n                                    const mFile = { ...file, contentMediaType: m };\n                                    return mFile;\n                                });\n                            }\n                        }\n                        else {\n                            Object.assign(json, file);\n                        }\n                        // if (this.unrepresentable === \"throw\") {\n                        //   throw new Error(\"File cannot be represented in JSON Schema\");\n                        // }\n                        break;\n                    }\n                    case \"transform\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"nullable\": {\n                        const inner = this.process(def.innerType, params);\n                        _json.anyOf = [inner, { type: \"null\" }];\n                        break;\n                    }\n                    case \"nonoptional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"success\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"default\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"prefault\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        if (this.io === \"input\")\n                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"catch\": {\n                        // use conditionals\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        let catchValue;\n                        try {\n                            catchValue = def.catchValue(undefined);\n                        }\n                        catch {\n                            throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                        }\n                        _json.default = catchValue;\n                        break;\n                    }\n                    case \"nan\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"NaN cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"template_literal\": {\n                        const json = _json;\n                        const pattern = schema._zod.pattern;\n                        if (!pattern)\n                            throw new Error(\"Pattern not found in template literal\");\n                        json.type = \"string\";\n                        json.pattern = pattern.source;\n                        break;\n                    }\n                    case \"pipe\": {\n                        const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"readonly\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.readOnly = true;\n                        break;\n                    }\n                    // passthrough types\n                    case \"promise\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"optional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"lazy\": {\n                        const innerType = schema._zod.innerType;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"custom\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    default: {\n                        def;\n                    }\n                }\n            }\n        }\n        // metadata\n        const meta = this.metadataRegistry.get(schema);\n        if (meta)\n            Object.assign(result.schema, meta);\n        if (this.io === \"input\" && isTransforming(schema)) {\n            // examples/defaults only apply to output type of pipe\n            delete result.schema.examples;\n            delete result.schema.default;\n        }\n        // set prefault as default\n        if (this.io === \"input\" && result.schema._prefault)\n            (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n        delete result.schema._prefault;\n        // pulling fresh from this.seen in case it was overwritten\n        const _result = this.seen.get(schema);\n        return _result.schema;\n    }\n    emit(schema, _params) {\n        const params = {\n            cycles: _params?.cycles ?? \"ref\",\n            reused: _params?.reused ?? \"inline\",\n            // unrepresentable: _params?.unrepresentable ?? \"throw\",\n            // uri: _params?.uri ?? ((id) => `${id}`),\n            external: _params?.external ?? undefined,\n        };\n        // iterate over seen map;\n        const root = this.seen.get(schema);\n        if (!root)\n            throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n        // initialize result with root schema fields\n        // Object.assign(result, seen.cached);\n        const makeURI = (entry) => {\n            // comparing the seen objects because sometimes\n            // multiple schemas map to the same seen object.\n            // e.g. lazy\n            // external is configured\n            const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            if (params.external) {\n                const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n                // check if schema is in the external registry\n                if (externalId)\n                    return { ref: params.external.uri(externalId) };\n                // otherwise, add to __shared\n                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n                entry[1].defId = id;\n                return { defId: id, ref: `${params.external.uri(\"__shared\")}#/${defsSegment}/${id}` };\n            }\n            if (entry[1] === root) {\n                return { ref: \"#\" };\n            }\n            // self-contained schema\n            const uriPrefix = `#`;\n            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n            return { defId, ref: defUriPrefix + defId };\n        };\n        // stored cached version in `def` property\n        // remove all properties, set $ref\n        const extractToDef = (entry) => {\n            if (entry[1].schema.$ref) {\n                return;\n            }\n            const seen = entry[1];\n            const { ref, defId } = makeURI(entry);\n            seen.def = { ...seen.schema };\n            // defId won't be set if the schema is a reference to an external schema\n            if (defId)\n                seen.defId = defId;\n            // wipe away all properties except $ref\n            const schema = seen.schema;\n            for (const key in schema) {\n                delete schema[key];\n            }\n            schema.$ref = ref;\n        };\n        // extract schemas into $defs\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            // convert root schema to # $ref\n            // also prevents root schema from being extracted\n            if (schema === entry[0]) {\n                // do not copy to defs...this is the root schema\n                extractToDef(entry);\n                continue;\n            }\n            // extract schemas that are in the external registry\n            if (params.external) {\n                const ext = params.external.registry.get(entry[0])?.id;\n                if (schema !== entry[0] && ext) {\n                    extractToDef(entry);\n                    continue;\n                }\n            }\n            // extract schemas with `id` meta\n            const id = this.metadataRegistry.get(entry[0])?.id;\n            if (id) {\n                extractToDef(entry);\n                continue;\n            }\n            // break cycles\n            if (seen.cycle) {\n                if (params.cycles === \"throw\") {\n                    throw new Error(\"Cycle detected: \" +\n                        `#/${seen.cycle?.join(\"/\")}/<root>` +\n                        '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n                }\n                else if (params.cycles === \"ref\") {\n                    extractToDef(entry);\n                }\n                continue;\n            }\n            // extract reused schemas\n            if (seen.count > 1) {\n                if (params.reused === \"ref\") {\n                    extractToDef(entry);\n                    // biome-ignore lint:\n                    continue;\n                }\n            }\n        }\n        // flatten _refs\n        const flattenRef = (zodSchema, params) => {\n            const seen = this.seen.get(zodSchema);\n            const schema = seen.def ?? seen.schema;\n            const _cached = { ...schema };\n            // already seen\n            if (seen.ref === null) {\n                return;\n            }\n            // flatten ref if defined\n            const ref = seen.ref;\n            seen.ref = null; // prevent recursion\n            if (ref) {\n                flattenRef(ref, params);\n                // merge referenced schema into current\n                const refSchema = this.seen.get(ref).schema;\n                if (refSchema.$ref && params.target === \"draft-7\") {\n                    schema.allOf = schema.allOf ?? [];\n                    schema.allOf.push(refSchema);\n                }\n                else {\n                    Object.assign(schema, refSchema);\n                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n                }\n            }\n            // execute overrides\n            if (!seen.isParent)\n                this.override({\n                    zodSchema: zodSchema,\n                    jsonSchema: schema,\n                });\n        };\n        for (const entry of [...this.seen.entries()].reverse()) {\n            flattenRef(entry[0], { target: this.target });\n        }\n        const result = {};\n        if (this.target === \"draft-2020-12\") {\n            result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n        }\n        else if (this.target === \"draft-7\") {\n            result.$schema = \"http://json-schema.org/draft-07/schema#\";\n        }\n        else {\n            console.warn(`Invalid target: ${this.target}`);\n        }\n        Object.assign(result, root.def);\n        // build defs object\n        const defs = params.external?.defs ?? {};\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            if (seen.def && seen.defId) {\n                defs[seen.defId] = seen.def;\n            }\n        }\n        // set definitions in result\n        if (!params.external && Object.keys(defs).length > 0) {\n            if (this.target === \"draft-2020-12\") {\n                result.$defs = defs;\n            }\n            else {\n                result.definitions = defs;\n            }\n        }\n        try {\n            // this \"finalizes\" this schema and ensures all cycles are removed\n            // each call to .emit() is functionally independent\n            // though the seen map is shared\n            return JSON.parse(JSON.stringify(result));\n        }\n        catch (_err) {\n            throw new Error(\"Error converting schema to JSON.\");\n        }\n    }\n}\nexport function toJSONSchema(input, _params) {\n    if (input instanceof $ZodRegistry) {\n        const gen = new JSONSchemaGenerator(_params);\n        const defs = {};\n        for (const entry of input._idmap.entries()) {\n            const [_, schema] = entry;\n            gen.process(schema);\n        }\n        const schemas = {};\n        const external = {\n            registry: input,\n            uri: _params?.uri || ((id) => id),\n            defs,\n        };\n        for (const entry of input._idmap.entries()) {\n            const [key, schema] = entry;\n            schemas[key] = gen.emit(schema, {\n                ..._params,\n                external,\n            });\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    const gen = new JSONSchemaGenerator(_params);\n    gen.process(input);\n    return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const schema = _schema;\n    const def = schema._zod.def;\n    switch (def.type) {\n        case \"string\":\n        case \"number\":\n        case \"bigint\":\n        case \"boolean\":\n        case \"date\":\n        case \"symbol\":\n        case \"undefined\":\n        case \"null\":\n        case \"any\":\n        case \"unknown\":\n        case \"never\":\n        case \"void\":\n        case \"literal\":\n        case \"enum\":\n        case \"nan\":\n        case \"file\":\n        case \"template_literal\":\n            return false;\n        case \"array\": {\n            return isTransforming(def.element, ctx);\n        }\n        case \"object\": {\n            for (const key in def.shape) {\n                if (isTransforming(def.shape[key], ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"union\": {\n            for (const option of def.options) {\n                if (isTransforming(option, ctx))\n                    return true;\n            }\n            return false;\n        }\n        case \"intersection\": {\n            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n        }\n        case \"tuple\": {\n            for (const item of def.items) {\n                if (isTransforming(item, ctx))\n                    return true;\n            }\n            if (def.rest && isTransforming(def.rest, ctx))\n                return true;\n            return false;\n        }\n        case \"record\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"map\": {\n            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n        }\n        case \"set\": {\n            return isTransforming(def.valueType, ctx);\n        }\n        // inner types\n        case \"promise\":\n        case \"optional\":\n        case \"nonoptional\":\n        case \"nullable\":\n        case \"readonly\":\n            return isTransforming(def.innerType, ctx);\n        case \"lazy\":\n            return isTransforming(def.getter(), ctx);\n        case \"default\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"prefault\": {\n            return isTransforming(def.innerType, ctx);\n        }\n        case \"custom\": {\n            return false;\n        }\n        case \"transform\": {\n            return true;\n        }\n        case \"pipe\": {\n            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n        }\n        case \"success\": {\n            return false;\n        }\n        case \"catch\": {\n            return false;\n        }\n        default:\n            def;\n    }\n    throw new Error(`Unknown schema type: ${def.type}`);\n}\n"],"mappings":";;;;;;;AAAA,SAASA,YAAY,EAAEC,cAAc,QAAQ,iBAAiB;AAC9D,SAASC,aAAa,QAAQ,WAAW;AACzC,WAAaC,mBAAmB;EAC5B,SAAAA,oBAAYC,MAAM,EAAE;IAAA,IAAAC,gBAAA,EAAAC,cAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,UAAA;IAAAC,eAAA,OAAAP,mBAAA;IAChB,IAAI,CAACQ,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,gBAAgB,IAAAP,gBAAA,GAAGD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAES,QAAQ,cAAAR,gBAAA,cAAAA,gBAAA,GAAIJ,cAAc;IAC1D,IAAI,CAACa,MAAM,IAAAR,cAAA,GAAGF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEU,MAAM,cAAAR,cAAA,cAAAA,cAAA,GAAI,eAAe;IAC/C,IAAI,CAACS,eAAe,IAAAR,qBAAA,GAAGH,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEW,eAAe,cAAAR,qBAAA,cAAAA,qBAAA,GAAI,OAAO;IACzD,IAAI,CAACS,QAAQ,IAAAR,gBAAA,GAAGJ,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEY,QAAQ,cAAAR,gBAAA,cAAAA,gBAAA,GAAK,YAAM,CAAE,CAAE;IAC/C,IAAI,CAACS,EAAE,IAAAR,UAAA,GAAGL,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEa,EAAE,cAAAR,UAAA,cAAAA,UAAA,GAAI,QAAQ;IAChC,IAAI,CAACS,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB;EAAC,OAAAC,YAAA,CAAAjB,mBAAA;IAAAkB,GAAA;IAAAC,KAAA,EACD,SAAAC,OAAOA,CAACC,MAAM,EAA0C;MAAA,IAAAC,qBAAA;QAAAC,YAAA;QAAAC,KAAA;QAAAC,UAAA;MAAA,IAAxCC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG;QAAEG,IAAI,EAAE,EAAE;QAAEC,UAAU,EAAE;MAAG,CAAC;MAClD,IAAIC,EAAE;MACN,IAAMC,GAAG,GAAGZ,MAAM,CAACa,IAAI,CAACD,GAAG;MAC3B,IAAME,SAAS,GAAG;QACdC,IAAI,EAAE,MAAM;QACZC,GAAG,EAAE,KAAK;QACVC,QAAQ,EAAE,WAAW;QACrBC,WAAW,EAAE,aAAa;QAC1BC,KAAK,EAAE,EAAE,CAAE;MACf,CAAC;MACD;MACA,IAAMzB,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC0B,GAAG,CAACpB,MAAM,CAAC;MAClC,IAAIN,IAAI,EAAE;QACNA,IAAI,CAAC2B,KAAK,EAAE;QACZ;QACA,IAAMC,OAAO,GAAGjB,OAAO,CAACK,UAAU,CAACa,QAAQ,CAACvB,MAAM,CAAC;QACnD,IAAIsB,OAAO,EAAE;UACT5B,IAAI,CAAC8B,KAAK,GAAGnB,OAAO,CAACI,IAAI;QAC7B;QACA,OAAOf,IAAI,CAACM,MAAM;MACtB;MACA;MACA,IAAMyB,MAAM,GAAG;QAAEzB,MAAM,EAAE,CAAC,CAAC;QAAEqB,KAAK,EAAE,CAAC;QAAEG,KAAK,EAAEhB;MAAU,CAAC;MACzD,IAAI,CAACd,IAAI,CAACgC,GAAG,CAAC1B,MAAM,EAAEyB,MAAM,CAAC;MAC7B;MACA,IAAME,cAAc,IAAA1B,qBAAA,GAAG,CAAAC,YAAA,GAAAF,MAAM,CAACa,IAAI,EAACe,YAAY,cAAA3B,qBAAA,uBAAxBA,qBAAA,CAAA4B,IAAA,CAAA3B,YAA2B,CAAC;MACnD,IAAIyB,cAAc,EAAE;QAChBF,MAAM,CAACzB,MAAM,GAAG2B,cAAc;MAClC,CAAC,MACI;QACD,IAAM/C,MAAM,GAAAkD,aAAA,CAAAA,aAAA,KACLzB,OAAO;UACVK,UAAU,KAAAqB,MAAA,CAAAC,kBAAA,CAAM3B,OAAO,CAACK,UAAU,IAAEV,MAAM,EAAC;UAC3CS,IAAI,EAAEJ,OAAO,CAACI;QAAI,EACrB;QACD,IAAMwB,MAAM,GAAGjC,MAAM,CAACa,IAAI,CAACoB,MAAM;QACjC,IAAIA,MAAM,EAAE;UACR;UACAR,MAAM,CAACS,GAAG,GAAGD,MAAM;UACnB,IAAI,CAAClC,OAAO,CAACkC,MAAM,EAAErD,MAAM,CAAC;UAC5B,IAAI,CAACc,IAAI,CAAC0B,GAAG,CAACa,MAAM,CAAC,CAACE,QAAQ,GAAG,IAAI;QACzC,CAAC,MACI;UACD,IAAMC,KAAK,GAAGX,MAAM,CAACzB,MAAM;UAC3B,QAAQY,GAAG,CAACyB,IAAI;YACZ,KAAK,QAAQ;cAAE;gBACX,IAAMC,IAAI,GAAGF,KAAK;gBAClBE,IAAI,CAACD,IAAI,GAAG,QAAQ;gBACpB,IAAAE,gBAAA,GAAgEvC,MAAM,CAACa,IAAI,CACtE2B,GAAG;kBADAC,OAAO,GAAAF,gBAAA,CAAPE,OAAO;kBAAEC,OAAO,GAAAH,gBAAA,CAAPG,OAAO;kBAAEC,MAAM,GAAAJ,gBAAA,CAANI,MAAM;kBAAEC,QAAQ,GAAAL,gBAAA,CAARK,QAAQ;kBAAEC,eAAe,GAAAN,gBAAA,CAAfM,eAAe;gBAE3D,IAAI,OAAOJ,OAAO,KAAK,QAAQ,EAC3BH,IAAI,CAACQ,SAAS,GAAGL,OAAO;gBAC5B,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAC3BJ,IAAI,CAACS,SAAS,GAAGL,OAAO;gBAC5B;gBACA,IAAIC,MAAM,EAAE;kBAAA,IAAAK,iBAAA;kBACRV,IAAI,CAACK,MAAM,IAAAK,iBAAA,GAAGlC,SAAS,CAAC6B,MAAM,CAAC,cAAAK,iBAAA,cAAAA,iBAAA,GAAIL,MAAM;kBACzC,IAAIL,IAAI,CAACK,MAAM,KAAK,EAAE,EAClB,OAAOL,IAAI,CAACK,MAAM,CAAC,CAAC;gBAC5B;gBACA,IAAIE,eAAe,EACfP,IAAI,CAACO,eAAe,GAAGA,eAAe;gBAC1C,IAAID,QAAQ,IAAIA,QAAQ,CAACK,IAAI,GAAG,CAAC,EAAE;kBAC/B,IAAMC,OAAO,GAAAlB,kBAAA,CAAOY,QAAQ,CAAC;kBAC7B,IAAIM,OAAO,CAAC3C,MAAM,KAAK,CAAC,EACpB+B,IAAI,CAACa,OAAO,GAAGD,OAAO,CAAC,CAAC,CAAC,CAACE,MAAM,CAAC,KAChC,IAAIF,OAAO,CAAC3C,MAAM,GAAG,CAAC,EAAE;oBACzBkB,MAAM,CAACzB,MAAM,CAACqD,KAAK,GAAArB,kBAAA,CACZkB,OAAO,CAACI,GAAG,CAAC,UAACnC,KAAK;sBAAA,OAAAW,aAAA,CAAAA,aAAA,KACb3B,KAAI,CAACb,MAAM,KAAK,SAAS,GAAG;wBAAE+C,IAAI,EAAE;sBAAS,CAAC,GAAG,CAAC,CAAC;wBACvDc,OAAO,EAAEhC,KAAK,CAACiC;sBAAM;oBAAA,CACvB,CAAC,CACN;kBACL;gBACJ;gBACA;cACJ;YACA,KAAK,QAAQ;cAAE;gBACX,IAAMd,MAAI,GAAGF,KAAK;gBAClB,IAAAmB,iBAAA,GAAqFvD,MAAM,CAACa,IAAI,CAAC2B,GAAG;kBAA5FC,QAAO,GAAAc,iBAAA,CAAPd,OAAO;kBAAEC,QAAO,GAAAa,iBAAA,CAAPb,OAAO;kBAAEC,OAAM,GAAAY,iBAAA,CAANZ,MAAM;kBAAEa,UAAU,GAAAD,iBAAA,CAAVC,UAAU;kBAAEC,gBAAgB,GAAAF,iBAAA,CAAhBE,gBAAgB;kBAAEC,gBAAgB,GAAAH,iBAAA,CAAhBG,gBAAgB;gBAChF,IAAI,OAAOf,OAAM,KAAK,QAAQ,IAAIA,OAAM,CAACpB,QAAQ,CAAC,KAAK,CAAC,EACpDe,MAAI,CAACD,IAAI,GAAG,SAAS,CAAC,KAEtBC,MAAI,CAACD,IAAI,GAAG,QAAQ;gBACxB,IAAI,OAAOqB,gBAAgB,KAAK,QAAQ,EACpCpB,MAAI,CAACoB,gBAAgB,GAAGA,gBAAgB;gBAC5C,IAAI,OAAOjB,QAAO,KAAK,QAAQ,EAAE;kBAC7BH,MAAI,CAACG,OAAO,GAAGA,QAAO;kBACtB,IAAI,OAAOiB,gBAAgB,KAAK,QAAQ,EAAE;oBACtC,IAAIA,gBAAgB,IAAIjB,QAAO,EAC3B,OAAOH,MAAI,CAACG,OAAO,CAAC,KAEpB,OAAOH,MAAI,CAACoB,gBAAgB;kBACpC;gBACJ;gBACA,IAAI,OAAOD,gBAAgB,KAAK,QAAQ,EACpCnB,MAAI,CAACmB,gBAAgB,GAAGA,gBAAgB;gBAC5C,IAAI,OAAOf,QAAO,KAAK,QAAQ,EAAE;kBAC7BJ,MAAI,CAACI,OAAO,GAAGA,QAAO;kBACtB,IAAI,OAAOe,gBAAgB,KAAK,QAAQ,EAAE;oBACtC,IAAIA,gBAAgB,IAAIf,QAAO,EAC3B,OAAOJ,MAAI,CAACI,OAAO,CAAC,KAEpB,OAAOJ,MAAI,CAACmB,gBAAgB;kBACpC;gBACJ;gBACA,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAC9BlB,MAAI,CAACkB,UAAU,GAAGA,UAAU;gBAChC;cACJ;YACA,KAAK,SAAS;cAAE;gBACZ,IAAMlB,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAACD,IAAI,GAAG,SAAS;gBACrB;cACJ;YACA,KAAK,QAAQ;cAAE;gBACX,IAAI,IAAI,CAAC9C,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,6CAA6C,CAAC;gBAClE;gBACA;cACJ;YACA,KAAK,QAAQ;cAAE;gBACX,IAAI,IAAI,CAACpE,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,8CAA8C,CAAC;gBACnE;gBACA;cACJ;YACA,KAAK,WAAW;cAAE;gBACd,IAAMrB,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAACD,IAAI,GAAG,MAAM;gBAClB;cACJ;YACA,KAAK,MAAM;cAAE;gBACTD,KAAK,CAACC,IAAI,GAAG,MAAM;gBACnB;cACJ;YACA,KAAK,KAAK;cAAE;gBACR;cACJ;YACA,KAAK,SAAS;cAAE;gBACZ;cACJ;YACA,KAAK,OAAO;cAAE;gBACVD,KAAK,CAACwB,GAAG,GAAG,CAAC,CAAC;gBACd;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAI,IAAI,CAACrE,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,2CAA2C,CAAC;gBAChE;gBACA;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAI,IAAI,CAACpE,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,2CAA2C,CAAC;gBAChE;gBACA;cACJ;YACA,KAAK,OAAO;cAAE;gBACV,IAAMrB,MAAI,GAAGF,KAAK;gBAClB,IAAAyB,iBAAA,GAA6B7D,MAAM,CAACa,IAAI,CAAC2B,GAAG;kBAApCC,SAAO,GAAAoB,iBAAA,CAAPpB,OAAO;kBAAEC,SAAO,GAAAmB,iBAAA,CAAPnB,OAAO;gBACxB,IAAI,OAAOD,SAAO,KAAK,QAAQ,EAC3BH,MAAI,CAACwB,QAAQ,GAAGrB,SAAO;gBAC3B,IAAI,OAAOC,SAAO,KAAK,QAAQ,EAC3BJ,MAAI,CAACyB,QAAQ,GAAGrB,SAAO;gBAC3BJ,MAAI,CAACD,IAAI,GAAG,OAAO;gBACnBC,MAAI,CAAC0B,KAAK,GAAG,IAAI,CAACjE,OAAO,CAACa,GAAG,CAACqD,OAAO,EAAAnC,aAAA,CAAAA,aAAA,KAAOlD,MAAM;kBAAE6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO;gBAAC,EAAE,CAAC;gBACtF;cACJ;YACA,KAAK,QAAQ;cAAE;gBAAA,IAAAyD,aAAA;gBACX,IAAM5B,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAACD,IAAI,GAAG,QAAQ;gBACpBC,MAAI,CAAC6B,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAMC,KAAK,GAAGxD,GAAG,CAACwD,KAAK,CAAC,CAAC;gBACzB,KAAK,IAAMvE,GAAG,IAAIuE,KAAK,EAAE;kBACrB9B,MAAI,CAAC6B,UAAU,CAACtE,GAAG,CAAC,GAAG,IAAI,CAACE,OAAO,CAACqE,KAAK,CAACvE,GAAG,CAAC,EAAAiC,aAAA,CAAAA,aAAA,KACvClD,MAAM;oBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,YAAY,EAAEZ,GAAG;kBAAC,EAC5C,CAAC;gBACN;gBACA;gBACA,IAAMwE,OAAO,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC,CAAC;gBAC3C;gBACA,IAAMK,YAAY,GAAG,IAAIH,GAAG,CAACtC,kBAAA,CAAIqC,OAAO,EAAEK,MAAM,CAAC,UAAC7E,GAAG,EAAK;kBACtD,IAAM8E,CAAC,GAAG/D,GAAG,CAACwD,KAAK,CAACvE,GAAG,CAAC,CAACgB,IAAI;kBAC7B,IAAIV,KAAI,CAACV,EAAE,KAAK,OAAO,EAAE;oBACrB,OAAOkF,CAAC,CAACC,KAAK,KAAKpE,SAAS;kBAChC,CAAC,MACI;oBACD,OAAOmE,CAAC,CAACE,MAAM,KAAKrE,SAAS;kBACjC;gBACJ,CAAC,CAAC,CAAC;gBACH,IAAIiE,YAAY,CAACxB,IAAI,GAAG,CAAC,EAAE;kBACvBX,MAAI,CAACwC,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAACP,YAAY,CAAC;gBAC5C;gBACA;gBACA,IAAI,EAAAP,aAAA,GAAAtD,GAAG,CAACqE,QAAQ,cAAAf,aAAA,uBAAZA,aAAA,CAAcrD,IAAI,CAACD,GAAG,CAACyB,IAAI,MAAK,OAAO,EAAE;kBACzC;kBACAC,MAAI,CAAC4C,oBAAoB,GAAG,KAAK;gBACrC,CAAC,MACI,IAAI,CAACtE,GAAG,CAACqE,QAAQ,EAAE;kBACpB;kBACA,IAAI,IAAI,CAACxF,EAAE,KAAK,QAAQ,EACpB6C,MAAI,CAAC4C,oBAAoB,GAAG,KAAK;gBACzC,CAAC,MACI,IAAItE,GAAG,CAACqE,QAAQ,EAAE;kBACnB3C,MAAI,CAAC4C,oBAAoB,GAAG,IAAI,CAACnF,OAAO,CAACa,GAAG,CAACqE,QAAQ,EAAAnD,aAAA,CAAAA,aAAA,KAC9ClD,MAAM;oBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,sBAAsB;kBAAC,EACjD,CAAC;gBACN;gBACA;cACJ;YACA,KAAK,OAAO;cAAE;gBACV,IAAM6B,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAAC6C,KAAK,GAAGvE,GAAG,CAACwE,OAAO,CAAC9B,GAAG,CAAC,UAAC+B,CAAC,EAAEC,CAAC;kBAAA,OAAKnF,KAAI,CAACJ,OAAO,CAACsF,CAAC,EAAAvD,aAAA,CAAAA,aAAA,KAC9ClD,MAAM;oBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO,EAAE6E,CAAC;kBAAC,EACrC,CAAC;gBAAA,EAAC;gBACH;cACJ;YACA,KAAK,cAAc;cAAE;gBACjB,IAAMhD,MAAI,GAAGF,KAAK;gBAClB,IAAMmD,CAAC,GAAG,IAAI,CAACxF,OAAO,CAACa,GAAG,CAAC4E,IAAI,EAAA1D,aAAA,CAAAA,aAAA,KACxBlD,MAAM;kBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO,EAAE,CAAC;gBAAC,EACrC,CAAC;gBACF,IAAMgF,CAAC,GAAG,IAAI,CAAC1F,OAAO,CAACa,GAAG,CAAC8E,KAAK,EAAA5D,aAAA,CAAAA,aAAA,KACzBlD,MAAM;kBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO,EAAE,CAAC;gBAAC,EACrC,CAAC;gBACF,IAAMkF,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,GAAG;kBAAA,OAAK,OAAO,IAAIA,GAAG,IAAIrB,MAAM,CAACC,IAAI,CAACoB,GAAG,CAAC,CAACrF,MAAM,KAAK,CAAC;gBAAA;gBACrF,IAAM8C,KAAK,MAAAtB,MAAA,CAAAC,kBAAA,CACH2D,oBAAoB,CAACJ,CAAC,CAAC,GAAGA,CAAC,CAAClC,KAAK,GAAG,CAACkC,CAAC,CAAC,GAAAvD,kBAAA,CACvC2D,oBAAoB,CAACF,CAAC,CAAC,GAAGA,CAAC,CAACpC,KAAK,GAAG,CAACoC,CAAC,CAAC,EAC9C;gBACDnD,MAAI,CAACe,KAAK,GAAGA,KAAK;gBAClB;cACJ;YACA,KAAK,OAAO;cAAE;gBACV,IAAMf,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAACD,IAAI,GAAG,OAAO;gBACnB,IAAMwD,WAAW,GAAGjF,GAAG,CAACoD,KAAK,CAACV,GAAG,CAAC,UAAC+B,CAAC,EAAEC,CAAC;kBAAA,OAAKnF,KAAI,CAACJ,OAAO,CAACsF,CAAC,EAAAvD,aAAA,CAAAA,aAAA,KAAOlD,MAAM;oBAAE6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,aAAa,EAAE6E,CAAC;kBAAC,EAAE,CAAC;gBAAA,EAAC;gBACrH,IAAI,IAAI,CAAChG,MAAM,KAAK,eAAe,EAAE;kBACjCgD,MAAI,CAACuD,WAAW,GAAGA,WAAW;gBAClC,CAAC,MACI;kBACDvD,MAAI,CAAC0B,KAAK,GAAG6B,WAAW;gBAC5B;gBACA,IAAIjF,GAAG,CAACkF,IAAI,EAAE;kBACV,IAAMA,IAAI,GAAG,IAAI,CAAC/F,OAAO,CAACa,GAAG,CAACkF,IAAI,EAAAhE,aAAA,CAAAA,aAAA,KAC3BlD,MAAM;oBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO;kBAAC,EAClC,CAAC;kBACF,IAAI,IAAI,CAACnB,MAAM,KAAK,eAAe,EAAE;oBACjCgD,MAAI,CAAC0B,KAAK,GAAG8B,IAAI;kBACrB,CAAC,MACI;oBACDxD,MAAI,CAACyD,eAAe,GAAGD,IAAI;kBAC/B;gBACJ;gBACA;gBACA,IAAIlF,GAAG,CAACkF,IAAI,EAAE;kBACVxD,MAAI,CAAC0B,KAAK,GAAG,IAAI,CAACjE,OAAO,CAACa,GAAG,CAACkF,IAAI,EAAAhE,aAAA,CAAAA,aAAA,KAC3BlD,MAAM;oBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,OAAO;kBAAC,EAClC,CAAC;gBACN;gBACA;gBACA,IAAAuF,iBAAA,GAA6BhG,MAAM,CAACa,IAAI,CAAC2B,GAAG;kBAApCC,SAAO,GAAAuD,iBAAA,CAAPvD,OAAO;kBAAEC,SAAO,GAAAsD,iBAAA,CAAPtD,OAAO;gBACxB,IAAI,OAAOD,SAAO,KAAK,QAAQ,EAC3BH,MAAI,CAACwB,QAAQ,GAAGrB,SAAO;gBAC3B,IAAI,OAAOC,SAAO,KAAK,QAAQ,EAC3BJ,MAAI,CAACyB,QAAQ,GAAGrB,SAAO;gBAC3B;cACJ;YACA,KAAK,QAAQ;cAAE;gBACX,IAAMJ,MAAI,GAAGF,KAAK;gBAClBE,MAAI,CAACD,IAAI,GAAG,QAAQ;gBACpBC,MAAI,CAAC2D,aAAa,GAAG,IAAI,CAAClG,OAAO,CAACa,GAAG,CAACsF,OAAO,EAAApE,aAAA,CAAAA,aAAA,KAAOlD,MAAM;kBAAE6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,eAAe;gBAAC,EAAE,CAAC;gBACtG6B,MAAI,CAAC4C,oBAAoB,GAAG,IAAI,CAACnF,OAAO,CAACa,GAAG,CAACuF,SAAS,EAAArE,aAAA,CAAAA,aAAA,KAC/ClD,MAAM;kBACT6B,IAAI,KAAAsB,MAAA,CAAAC,kBAAA,CAAMpD,MAAM,CAAC6B,IAAI,IAAE,sBAAsB;gBAAC,EACjD,CAAC;gBACF;cACJ;YACA,KAAK,KAAK;cAAE;gBACR,IAAI,IAAI,CAAClB,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,0CAA0C,CAAC;gBAC/D;gBACA;cACJ;YACA,KAAK,KAAK;cAAE;gBACR,IAAI,IAAI,CAACpE,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,0CAA0C,CAAC;gBAC/D;gBACA;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAMrB,MAAI,GAAGF,KAAK;gBAClB,IAAMgE,MAAM,GAAG1H,aAAa,CAACkC,GAAG,CAACyF,OAAO,CAAC;gBACzC;gBACA,IAAID,MAAM,CAACE,KAAK,CAAC,UAAC3B,CAAC;kBAAA,OAAK,OAAOA,CAAC,KAAK,QAAQ;gBAAA,EAAC,EAC1CrC,MAAI,CAACD,IAAI,GAAG,QAAQ;gBACxB,IAAI+D,MAAM,CAACE,KAAK,CAAC,UAAC3B,CAAC;kBAAA,OAAK,OAAOA,CAAC,KAAK,QAAQ;gBAAA,EAAC,EAC1CrC,MAAI,CAACD,IAAI,GAAG,QAAQ;gBACxBC,MAAI,CAACiE,IAAI,GAAGH,MAAM;gBAClB;cACJ;YACA,KAAK,SAAS;cAAE;gBACZ,IAAM9D,OAAI,GAAGF,KAAK;gBAClB,IAAMoE,IAAI,GAAG,EAAE;gBAAC,IAAAC,SAAA,GAAAC,0BAAA,CACE9F,GAAG,CAACwF,MAAM;kBAAAO,KAAA;gBAAA;kBAA5B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA8B;oBAAA,IAAnBlB,IAAG,GAAAe,KAAA,CAAA7G,KAAA;oBACV,IAAI8F,IAAG,KAAKpF,SAAS,EAAE;sBACnB,IAAI,IAAI,CAACjB,eAAe,KAAK,OAAO,EAAE;wBAClC,MAAM,IAAIoE,KAAK,CAAC,0DAA0D,CAAC;sBAC/E,CAAC,MACI;wBACD;sBAAA;oBAER,CAAC,MACI,IAAI,OAAOiC,IAAG,KAAK,QAAQ,EAAE;sBAC9B,IAAI,IAAI,CAACrG,eAAe,KAAK,OAAO,EAAE;wBAClC,MAAM,IAAIoE,KAAK,CAAC,sDAAsD,CAAC;sBAC3E,CAAC,MACI;wBACD6C,IAAI,CAACO,IAAI,CAACC,MAAM,CAACpB,IAAG,CAAC,CAAC;sBAC1B;oBACJ,CAAC,MACI;sBACDY,IAAI,CAACO,IAAI,CAACnB,IAAG,CAAC;oBAClB;kBACJ;gBAAC,SAAAqB,GAAA;kBAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;gBAAA;kBAAAR,SAAA,CAAAU,CAAA;gBAAA;gBACD,IAAIX,IAAI,CAACjG,MAAM,KAAK,CAAC,EAAE;kBACnB;gBAAA,CACH,MACI,IAAIiG,IAAI,CAACjG,MAAM,KAAK,CAAC,EAAE;kBACxB,IAAMqF,GAAG,GAAGY,IAAI,CAAC,CAAC,CAAC;kBACnBlE,OAAI,CAACD,IAAI,GAAGuD,GAAG,KAAK,IAAI,GAAG,MAAM,GAAG,OAAOA,GAAG;kBAC9CtD,OAAI,CAAC8E,KAAK,GAAGxB,GAAG;gBACpB,CAAC,MACI;kBACD,IAAIY,IAAI,CAACF,KAAK,CAAC,UAAC3B,CAAC;oBAAA,OAAK,OAAOA,CAAC,KAAK,QAAQ;kBAAA,EAAC,EACxCrC,OAAI,CAACD,IAAI,GAAG,QAAQ;kBACxB,IAAImE,IAAI,CAACF,KAAK,CAAC,UAAC3B,CAAC;oBAAA,OAAK,OAAOA,CAAC,KAAK,QAAQ;kBAAA,EAAC,EACxCrC,OAAI,CAACD,IAAI,GAAG,QAAQ;kBACxB,IAAImE,IAAI,CAACF,KAAK,CAAC,UAAC3B,CAAC;oBAAA,OAAK,OAAOA,CAAC,KAAK,SAAS;kBAAA,EAAC,EACzCrC,OAAI,CAACD,IAAI,GAAG,QAAQ;kBACxB,IAAImE,IAAI,CAACF,KAAK,CAAC,UAAC3B,CAAC;oBAAA,OAAKA,CAAC,KAAK,IAAI;kBAAA,EAAC,EAC7BrC,OAAI,CAACD,IAAI,GAAG,MAAM;kBACtBC,OAAI,CAACiE,IAAI,GAAGC,IAAI;gBACpB;gBACA;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAMlE,OAAI,GAAGF,KAAK;gBAClB,IAAMiF,IAAI,GAAG;kBACThF,IAAI,EAAE,QAAQ;kBACdM,MAAM,EAAE,QAAQ;kBAChBE,eAAe,EAAE;gBACrB,CAAC;gBACD,IAAAyE,iBAAA,GAAmCtH,MAAM,CAACa,IAAI,CAAC2B,GAAG;kBAA1CC,SAAO,GAAA6E,iBAAA,CAAP7E,OAAO;kBAAEC,SAAO,GAAA4E,iBAAA,CAAP5E,OAAO;kBAAE6E,IAAI,GAAAD,iBAAA,CAAJC,IAAI;gBAC9B,IAAI9E,SAAO,KAAKjC,SAAS,EACrB6G,IAAI,CAACvE,SAAS,GAAGL,SAAO;gBAC5B,IAAIC,SAAO,KAAKlC,SAAS,EACrB6G,IAAI,CAACtE,SAAS,GAAGL,SAAO;gBAC5B,IAAI6E,IAAI,EAAE;kBACN,IAAIA,IAAI,CAAChH,MAAM,KAAK,CAAC,EAAE;oBACnB8G,IAAI,CAACG,gBAAgB,GAAGD,IAAI,CAAC,CAAC,CAAC;oBAC/BhD,MAAM,CAACkD,MAAM,CAACnF,OAAI,EAAE+E,IAAI,CAAC;kBAC7B,CAAC,MACI;oBACD/E,OAAI,CAAC6C,KAAK,GAAGoC,IAAI,CAACjE,GAAG,CAAC,UAACoE,CAAC,EAAK;sBACzB,IAAMC,KAAK,GAAA7F,aAAA,CAAAA,aAAA,KAAQuF,IAAI;wBAAEG,gBAAgB,EAAEE;sBAAC,EAAE;sBAC9C,OAAOC,KAAK;oBAChB,CAAC,CAAC;kBACN;gBACJ,CAAC,MACI;kBACDpD,MAAM,CAACkD,MAAM,CAACnF,OAAI,EAAE+E,IAAI,CAAC;gBAC7B;gBACA;gBACA;gBACA;gBACA;cACJ;YACA,KAAK,WAAW;cAAE;gBACd,IAAI,IAAI,CAAC9H,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,iDAAiD,CAAC;gBACtE;gBACA;cACJ;YACA,KAAK,UAAU;cAAE;gBACb,IAAMiE,KAAK,GAAG,IAAI,CAAC7H,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACjDwD,KAAK,CAAC+C,KAAK,GAAG,CAACyC,KAAK,EAAE;kBAAEvF,IAAI,EAAE;gBAAO,CAAC,CAAC;gBACvC;cACJ;YACA,KAAK,aAAa;cAAE;gBAChB,IAAI,CAACtC,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1B;cACJ;YACA,KAAK,SAAS;cAAE;gBACZ,IAAMvF,OAAI,GAAGF,KAAK;gBAClBE,OAAI,CAACD,IAAI,GAAG,SAAS;gBACrB;cACJ;YACA,KAAK,SAAS;cAAE;gBACZ,IAAI,CAACtC,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1BzF,KAAK,CAAC0F,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACrH,GAAG,CAACsH,YAAY,CAAC,CAAC;gBAC5D;cACJ;YACA,KAAK,UAAU;cAAE;gBACb,IAAI,CAACnI,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1B,IAAI,IAAI,CAACpI,EAAE,KAAK,OAAO,EACnB2C,KAAK,CAAC+F,SAAS,GAAGJ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACrH,GAAG,CAACsH,YAAY,CAAC,CAAC;gBAClE;cACJ;YACA,KAAK,OAAO;cAAE;gBACV;gBACA,IAAI,CAACnI,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1B,IAAIO,UAAU;gBACd,IAAI;kBACAA,UAAU,GAAGxH,GAAG,CAACwH,UAAU,CAAC5H,SAAS,CAAC;gBAC1C,CAAC,CACD,OAAA6H,OAAA,EAAM;kBACF,MAAM,IAAI1E,KAAK,CAAC,uDAAuD,CAAC;gBAC5E;gBACAvB,KAAK,CAAC0F,OAAO,GAAGM,UAAU;gBAC1B;cACJ;YACA,KAAK,KAAK;cAAE;gBACR,IAAI,IAAI,CAAC7I,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,0CAA0C,CAAC;gBAC/D;gBACA;cACJ;YACA,KAAK,kBAAkB;cAAE;gBACrB,IAAMrB,OAAI,GAAGF,KAAK;gBAClB,IAAMe,OAAO,GAAGnD,MAAM,CAACa,IAAI,CAACsC,OAAO;gBACnC,IAAI,CAACA,OAAO,EACR,MAAM,IAAIQ,KAAK,CAAC,uCAAuC,CAAC;gBAC5DrB,OAAI,CAACD,IAAI,GAAG,QAAQ;gBACpBC,OAAI,CAACa,OAAO,GAAGA,OAAO,CAACC,MAAM;gBAC7B;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAMyE,SAAS,GAAG,IAAI,CAACpI,EAAE,KAAK,OAAO,GAAImB,GAAG,CAAC0H,EAAE,CAACzH,IAAI,CAACD,GAAG,CAACyB,IAAI,KAAK,WAAW,GAAGzB,GAAG,CAAC2H,GAAG,GAAG3H,GAAG,CAAC0H,EAAE,GAAI1H,GAAG,CAAC2H,GAAG;gBAC3G,IAAI,CAACxI,OAAO,CAAC8H,SAAS,EAAEjJ,MAAM,CAAC;gBAC/B6C,MAAM,CAACS,GAAG,GAAG2F,SAAS;gBACtB;cACJ;YACA,KAAK,UAAU;cAAE;gBACb,IAAI,CAAC9H,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1BzF,KAAK,CAACoG,QAAQ,GAAG,IAAI;gBACrB;cACJ;YACA;YACA,KAAK,SAAS;cAAE;gBACZ,IAAI,CAACzI,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1B;cACJ;YACA,KAAK,UAAU;cAAE;gBACb,IAAI,CAAC9H,OAAO,CAACa,GAAG,CAACiH,SAAS,EAAEjJ,MAAM,CAAC;gBACnC6C,MAAM,CAACS,GAAG,GAAGtB,GAAG,CAACiH,SAAS;gBAC1B;cACJ;YACA,KAAK,MAAM;cAAE;gBACT,IAAMA,UAAS,GAAG7H,MAAM,CAACa,IAAI,CAACgH,SAAS;gBACvC,IAAI,CAAC9H,OAAO,CAAC8H,UAAS,EAAEjJ,MAAM,CAAC;gBAC/B6C,MAAM,CAACS,GAAG,GAAG2F,UAAS;gBACtB;cACJ;YACA,KAAK,QAAQ;cAAE;gBACX,IAAI,IAAI,CAACtI,eAAe,KAAK,OAAO,EAAE;kBAClC,MAAM,IAAIoE,KAAK,CAAC,mDAAmD,CAAC;gBACxE;gBACA;cACJ;YACA;cAAS;gBACL/C,GAAG;cACP;UACJ;QACJ;MACJ;MACA;MACA,IAAM6H,IAAI,GAAG,IAAI,CAACrJ,gBAAgB,CAACgC,GAAG,CAACpB,MAAM,CAAC;MAC9C,IAAIyI,IAAI,EACJlE,MAAM,CAACkD,MAAM,CAAChG,MAAM,CAACzB,MAAM,EAAEyI,IAAI,CAAC;MACtC,IAAI,IAAI,CAAChJ,EAAE,KAAK,OAAO,IAAIiJ,cAAc,CAAC1I,MAAM,CAAC,EAAE;QAC/C;QACA,OAAOyB,MAAM,CAACzB,MAAM,CAAC2I,QAAQ;QAC7B,OAAOlH,MAAM,CAACzB,MAAM,CAAC8H,OAAO;MAChC;MACA;MACA,IAAI,IAAI,CAACrI,EAAE,KAAK,OAAO,IAAIgC,MAAM,CAACzB,MAAM,CAACmI,SAAS,EAC9C,CAAA/H,UAAA,IAACO,EAAE,GAAGc,MAAM,CAACzB,MAAM,EAAE8H,OAAO,cAAA1H,UAAA,cAAAA,UAAA,GAAKO,EAAE,CAACmH,OAAO,GAAGrG,MAAM,CAACzB,MAAM,CAACmI,SAAS;MACzE,OAAO1G,MAAM,CAACzB,MAAM,CAACmI,SAAS;MAC9B;MACA,IAAMS,OAAO,GAAG,IAAI,CAAClJ,IAAI,CAAC0B,GAAG,CAACpB,MAAM,CAAC;MACrC,OAAO4I,OAAO,CAAC5I,MAAM;IACzB;EAAC;IAAAH,GAAA;IAAAC,KAAA,EACD,SAAA+I,IAAIA,CAAC7I,MAAM,EAAEK,OAAO,EAAE;MAAA,IAAAyI,cAAA;QAAAC,cAAA;QAAAC,gBAAA;QAAAC,MAAA;QAAAC,qBAAA;QAAAC,iBAAA;MAClB,IAAMvK,MAAM,GAAG;QACXwK,MAAM,GAAAN,cAAA,GAAEzI,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE+I,MAAM,cAAAN,cAAA,cAAAA,cAAA,GAAI,KAAK;QAChCO,MAAM,GAAAN,cAAA,GAAE1I,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEgJ,MAAM,cAAAN,cAAA,cAAAA,cAAA,GAAI,QAAQ;QACnC;QACA;QACAO,QAAQ,GAAAN,gBAAA,GAAE3I,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiJ,QAAQ,cAAAN,gBAAA,cAAAA,gBAAA,GAAIxI;MACnC,CAAC;MACD;MACA,IAAM+I,IAAI,GAAG,IAAI,CAAC7J,IAAI,CAAC0B,GAAG,CAACpB,MAAM,CAAC;MAClC,IAAI,CAACuJ,IAAI,EACL,MAAM,IAAI5F,KAAK,CAAC,2CAA2C,CAAC;MAChE;MACA;MACA,IAAM6F,OAAO,GAAG,SAAVA,OAAOA,CAAIC,KAAK,EAAK;QAAA,IAAAC,kBAAA;QACvB;QACA;QACA;QACA;QACA,IAAMC,WAAW,GAAGV,MAAI,CAAC3J,MAAM,KAAK,eAAe,GAAG,OAAO,GAAG,aAAa;QAC7E,IAAIV,MAAM,CAAC0K,QAAQ,EAAE;UAAA,IAAAM,qBAAA,EAAAC,IAAA,EAAAC,cAAA;UACjB,IAAMC,UAAU,IAAAH,qBAAA,GAAGhL,MAAM,CAAC0K,QAAQ,CAACU,QAAQ,CAAC5I,GAAG,CAACqI,KAAK,CAAC,CAAC,CAAC,CAAC,cAAAG,qBAAA,uBAAtCA,qBAAA,CAAwCK,EAAE,CAAC,CAAC;UAC/D;UACA,IAAIF,UAAU,EACV,OAAO;YAAE7H,GAAG,EAAEtD,MAAM,CAAC0K,QAAQ,CAACY,GAAG,CAACH,UAAU;UAAE,CAAC;UACnD;UACA,IAAME,EAAE,IAAAJ,IAAA,IAAAC,cAAA,GAAGL,KAAK,CAAC,CAAC,CAAC,CAACU,KAAK,cAAAL,cAAA,cAAAA,cAAA,GAAIL,KAAK,CAAC,CAAC,CAAC,CAACzJ,MAAM,CAACiK,EAAE,cAAAJ,IAAA,cAAAA,IAAA,YAAA9H,MAAA,CAAakH,MAAI,CAAC9J,OAAO,EAAE,CAAE;UAC5EsK,KAAK,CAAC,CAAC,CAAC,CAACU,KAAK,GAAGF,EAAE;UACnB,OAAO;YAAEE,KAAK,EAAEF,EAAE;YAAE/H,GAAG,KAAAH,MAAA,CAAKnD,MAAM,CAAC0K,QAAQ,CAACY,GAAG,CAAC,UAAU,CAAC,QAAAnI,MAAA,CAAK4H,WAAW,OAAA5H,MAAA,CAAIkI,EAAE;UAAG,CAAC;QACzF;QACA,IAAIR,KAAK,CAAC,CAAC,CAAC,KAAKF,IAAI,EAAE;UACnB,OAAO;YAAErH,GAAG,EAAE;UAAI,CAAC;QACvB;QACA;QACA,IAAMkI,SAAS,MAAM;QACrB,IAAMC,YAAY,MAAAtI,MAAA,CAAMqI,SAAS,OAAArI,MAAA,CAAI4H,WAAW,MAAG;QACnD,IAAMQ,KAAK,IAAAT,kBAAA,GAAGD,KAAK,CAAC,CAAC,CAAC,CAACzJ,MAAM,CAACiK,EAAE,cAAAP,kBAAA,cAAAA,kBAAA,cAAA3H,MAAA,CAAekH,MAAI,CAAC9J,OAAO,EAAE,CAAE;QAC/D,OAAO;UAAEgL,KAAK,EAALA,KAAK;UAAEjI,GAAG,EAAEmI,YAAY,GAAGF;QAAM,CAAC;MAC/C,CAAC;MACD;MACA;MACA,IAAMG,YAAY,GAAG,SAAfA,YAAYA,CAAIb,KAAK,EAAK;QAC5B,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACzJ,MAAM,CAACuK,IAAI,EAAE;UACtB;QACJ;QACA,IAAM7K,IAAI,GAAG+J,KAAK,CAAC,CAAC,CAAC;QACrB,IAAAe,QAAA,GAAuBhB,OAAO,CAACC,KAAK,CAAC;UAA7BvH,GAAG,GAAAsI,QAAA,CAAHtI,GAAG;UAAEiI,KAAK,GAAAK,QAAA,CAALL,KAAK;QAClBzK,IAAI,CAACkB,GAAG,GAAAkB,aAAA,KAAQpC,IAAI,CAACM,MAAM,CAAE;QAC7B;QACA,IAAImK,KAAK,EACLzK,IAAI,CAACyK,KAAK,GAAGA,KAAK;QACtB;QACA,IAAMnK,MAAM,GAAGN,IAAI,CAACM,MAAM;QAC1B,KAAK,IAAMH,GAAG,IAAIG,MAAM,EAAE;UACtB,OAAOA,MAAM,CAACH,GAAG,CAAC;QACtB;QACAG,MAAM,CAACuK,IAAI,GAAGrI,GAAG;MACrB,CAAC;MACD;MAAA,IAAAuI,UAAA,GAAA/D,0BAAA,CACoB,IAAI,CAAChH,IAAI,CAAC2G,OAAO,CAAC,CAAC;QAAAqE,MAAA;MAAA;QAAvC,KAAAD,UAAA,CAAA7D,CAAA,MAAA8D,MAAA,GAAAD,UAAA,CAAA5D,CAAA,IAAAC,IAAA,GAAyC;UAAA,IAAA6D,qBAAA;UAAA,IAA9BlB,KAAK,GAAAiB,MAAA,CAAA5K,KAAA;UACZ,IAAMJ,IAAI,GAAG+J,KAAK,CAAC,CAAC,CAAC;UACrB;UACA;UACA,IAAIzJ,MAAM,KAAKyJ,KAAK,CAAC,CAAC,CAAC,EAAE;YACrB;YACAa,YAAY,CAACb,KAAK,CAAC;YACnB;UACJ;UACA;UACA,IAAI7K,MAAM,CAAC0K,QAAQ,EAAE;YAAA,IAAAsB,sBAAA;YACjB,IAAMC,GAAG,IAAAD,sBAAA,GAAGhM,MAAM,CAAC0K,QAAQ,CAACU,QAAQ,CAAC5I,GAAG,CAACqI,KAAK,CAAC,CAAC,CAAC,CAAC,cAAAmB,sBAAA,uBAAtCA,sBAAA,CAAwCX,EAAE;YACtD,IAAIjK,MAAM,KAAKyJ,KAAK,CAAC,CAAC,CAAC,IAAIoB,GAAG,EAAE;cAC5BP,YAAY,CAACb,KAAK,CAAC;cACnB;YACJ;UACJ;UACA;UACA,IAAMQ,EAAE,IAAAU,qBAAA,GAAG,IAAI,CAACvL,gBAAgB,CAACgC,GAAG,CAACqI,KAAK,CAAC,CAAC,CAAC,CAAC,cAAAkB,qBAAA,uBAAnCA,qBAAA,CAAqCV,EAAE;UAClD,IAAIA,EAAE,EAAE;YACJK,YAAY,CAACb,KAAK,CAAC;YACnB;UACJ;UACA;UACA,IAAI/J,IAAI,CAAC8B,KAAK,EAAE;YACZ,IAAI5C,MAAM,CAACwK,MAAM,KAAK,OAAO,EAAE;cAAA,IAAA0B,WAAA;cAC3B,MAAM,IAAInH,KAAK,CAAC,kBAAkB,QAAA5B,MAAA,EAAA+I,WAAA,GACzBpL,IAAI,CAAC8B,KAAK,cAAAsJ,WAAA,uBAAVA,WAAA,CAAYC,IAAI,CAAC,GAAG,CAAC,YAAS,GACnC,kFAAkF,CAAC;YAC3F,CAAC,MACI,IAAInM,MAAM,CAACwK,MAAM,KAAK,KAAK,EAAE;cAC9BkB,YAAY,CAACb,KAAK,CAAC;YACvB;YACA;UACJ;UACA;UACA,IAAI/J,IAAI,CAAC2B,KAAK,GAAG,CAAC,EAAE;YAChB,IAAIzC,MAAM,CAACyK,MAAM,KAAK,KAAK,EAAE;cACzBiB,YAAY,CAACb,KAAK,CAAC;cACnB;cACA;YACJ;UACJ;QACJ;QACA;MAAA,SAAAxC,GAAA;QAAAwD,UAAA,CAAAvD,CAAA,CAAAD,GAAA;MAAA;QAAAwD,UAAA,CAAAtD,CAAA;MAAA;MACA,IAAM6D,WAAU,GAAG,SAAbA,UAAUA,CAAIC,SAAS,EAAErM,MAAM,EAAK;QAAA,IAAAsM,SAAA;QACtC,IAAMxL,IAAI,GAAGuJ,MAAI,CAACvJ,IAAI,CAAC0B,GAAG,CAAC6J,SAAS,CAAC;QACrC,IAAMjL,MAAM,IAAAkL,SAAA,GAAGxL,IAAI,CAACkB,GAAG,cAAAsK,SAAA,cAAAA,SAAA,GAAIxL,IAAI,CAACM,MAAM;QACtC,IAAMmL,OAAO,GAAArJ,aAAA,KAAQ9B,MAAM,CAAE;QAC7B;QACA,IAAIN,IAAI,CAACwC,GAAG,KAAK,IAAI,EAAE;UACnB;QACJ;QACA;QACA,IAAMA,GAAG,GAAGxC,IAAI,CAACwC,GAAG;QACpBxC,IAAI,CAACwC,GAAG,GAAG,IAAI,CAAC,CAAC;QACjB,IAAIA,GAAG,EAAE;UACL8I,WAAU,CAAC9I,GAAG,EAAEtD,MAAM,CAAC;UACvB;UACA,IAAMwM,SAAS,GAAGnC,MAAI,CAACvJ,IAAI,CAAC0B,GAAG,CAACc,GAAG,CAAC,CAAClC,MAAM;UAC3C,IAAIoL,SAAS,CAACb,IAAI,IAAI3L,MAAM,CAACU,MAAM,KAAK,SAAS,EAAE;YAAA,IAAA+L,aAAA;YAC/CrL,MAAM,CAACqD,KAAK,IAAAgI,aAAA,GAAGrL,MAAM,CAACqD,KAAK,cAAAgI,aAAA,cAAAA,aAAA,GAAI,EAAE;YACjCrL,MAAM,CAACqD,KAAK,CAAC0D,IAAI,CAACqE,SAAS,CAAC;UAChC,CAAC,MACI;YACD7G,MAAM,CAACkD,MAAM,CAACzH,MAAM,EAAEoL,SAAS,CAAC;YAChC7G,MAAM,CAACkD,MAAM,CAACzH,MAAM,EAAEmL,OAAO,CAAC,CAAC,CAAC;UACpC;QACJ;QACA;QACA,IAAI,CAACzL,IAAI,CAACyC,QAAQ,EACd8G,MAAI,CAACzJ,QAAQ,CAAC;UACVyL,SAAS,EAAEA,SAAS;UACpBK,UAAU,EAAEtL;QAChB,CAAC,CAAC;MACV,CAAC;MAAC,IAAAuL,UAAA,GAAA7E,0BAAA,CACkB1E,kBAAA,CAAI,IAAI,CAACtC,IAAI,CAAC2G,OAAO,CAAC,CAAC,EAAEmF,OAAO,CAAC,CAAC;QAAAC,MAAA;MAAA;QAAtD,KAAAF,UAAA,CAAA3E,CAAA,MAAA6E,MAAA,GAAAF,UAAA,CAAA1E,CAAA,IAAAC,IAAA,GAAwD;UAAA,IAA7C2C,MAAK,GAAAgC,MAAA,CAAA3L,KAAA;UACZkL,WAAU,CAACvB,MAAK,CAAC,CAAC,CAAC,EAAE;YAAEnK,MAAM,EAAE,IAAI,CAACA;UAAO,CAAC,CAAC;QACjD;MAAC,SAAA2H,GAAA;QAAAsE,UAAA,CAAArE,CAAA,CAAAD,GAAA;MAAA;QAAAsE,UAAA,CAAApE,CAAA;MAAA;MACD,IAAM1F,MAAM,GAAG,CAAC,CAAC;MACjB,IAAI,IAAI,CAACnC,MAAM,KAAK,eAAe,EAAE;QACjCmC,MAAM,CAACiK,OAAO,GAAG,8CAA8C;MACnE,CAAC,MACI,IAAI,IAAI,CAACpM,MAAM,KAAK,SAAS,EAAE;QAChCmC,MAAM,CAACiK,OAAO,GAAG,yCAAyC;MAC9D,CAAC,MACI;QACDC,OAAO,CAACC,IAAI,oBAAA7J,MAAA,CAAoB,IAAI,CAACzC,MAAM,CAAE,CAAC;MAClD;MACAiF,MAAM,CAACkD,MAAM,CAAChG,MAAM,EAAE8H,IAAI,CAAC3I,GAAG,CAAC;MAC/B;MACA,IAAMiL,IAAI,IAAA3C,qBAAA,IAAAC,iBAAA,GAAGvK,MAAM,CAAC0K,QAAQ,cAAAH,iBAAA,uBAAfA,iBAAA,CAAiB0C,IAAI,cAAA3C,qBAAA,cAAAA,qBAAA,GAAI,CAAC,CAAC;MAAC,IAAA4C,UAAA,GAAApF,0BAAA,CACrB,IAAI,CAAChH,IAAI,CAAC2G,OAAO,CAAC,CAAC;QAAA0F,MAAA;MAAA;QAAvC,KAAAD,UAAA,CAAAlF,CAAA,MAAAmF,MAAA,GAAAD,UAAA,CAAAjF,CAAA,IAAAC,IAAA,GAAyC;UAAA,IAA9B2C,OAAK,GAAAsC,MAAA,CAAAjM,KAAA;UACZ,IAAMJ,KAAI,GAAG+J,OAAK,CAAC,CAAC,CAAC;UACrB,IAAI/J,KAAI,CAACkB,GAAG,IAAIlB,KAAI,CAACyK,KAAK,EAAE;YACxB0B,IAAI,CAACnM,KAAI,CAACyK,KAAK,CAAC,GAAGzK,KAAI,CAACkB,GAAG;UAC/B;QACJ;QACA;MAAA,SAAAqG,GAAA;QAAA6E,UAAA,CAAA5E,CAAA,CAAAD,GAAA;MAAA;QAAA6E,UAAA,CAAA3E,CAAA;MAAA;MACA,IAAI,CAACvI,MAAM,CAAC0K,QAAQ,IAAI/E,MAAM,CAACC,IAAI,CAACqH,IAAI,CAAC,CAACtL,MAAM,GAAG,CAAC,EAAE;QAClD,IAAI,IAAI,CAACjB,MAAM,KAAK,eAAe,EAAE;UACjCmC,MAAM,CAACuK,KAAK,GAAGH,IAAI;QACvB,CAAC,MACI;UACDpK,MAAM,CAACwK,WAAW,GAAGJ,IAAI;QAC7B;MACJ;MACA,IAAI;QACA;QACA;QACA;QACA,OAAO9D,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACxG,MAAM,CAAC,CAAC;MAC7C,CAAC,CACD,OAAOyK,IAAI,EAAE;QACT,MAAM,IAAIvI,KAAK,CAAC,kCAAkC,CAAC;MACvD;IACJ;EAAC;AAAA;AAEL,OAAO,SAAS/B,YAAYA,CAACuK,KAAK,EAAE9L,OAAO,EAAE;EACzC,IAAI8L,KAAK,YAAY3N,YAAY,EAAE;IAC/B,IAAM4N,IAAG,GAAG,IAAIzN,mBAAmB,CAAC0B,OAAO,CAAC;IAC5C,IAAMwL,IAAI,GAAG,CAAC,CAAC;IAAC,IAAAQ,UAAA,GAAA3F,0BAAA,CACIyF,KAAK,CAACG,MAAM,CAACjG,OAAO,CAAC,CAAC;MAAAkG,MAAA;IAAA;MAA1C,KAAAF,UAAA,CAAAzF,CAAA,MAAA2F,MAAA,GAAAF,UAAA,CAAAxF,CAAA,IAAAC,IAAA,GAA4C;QAAA,IAAjC2C,KAAK,GAAA8C,MAAA,CAAAzM,KAAA;QACZ,IAAA0M,OAAA,GAAAC,cAAA,CAAoBhD,KAAK;UAAlBiD,CAAC,GAAAF,OAAA;UAAExM,MAAM,GAAAwM,OAAA;QAChBJ,IAAG,CAACrM,OAAO,CAACC,MAAM,CAAC;MACvB;IAAC,SAAAiH,GAAA;MAAAoF,UAAA,CAAAnF,CAAA,CAAAD,GAAA;IAAA;MAAAoF,UAAA,CAAAlF,CAAA;IAAA;IACD,IAAMwF,OAAO,GAAG,CAAC,CAAC;IAClB,IAAMrD,QAAQ,GAAG;MACbU,QAAQ,EAAEmC,KAAK;MACfjC,GAAG,EAAE,CAAA7J,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE6J,GAAG,KAAK,UAACD,EAAE;QAAA,OAAKA,EAAE;MAAA,CAAC;MACjC4B,IAAI,EAAJA;IACJ,CAAC;IAAC,IAAAe,UAAA,GAAAlG,0BAAA,CACkByF,KAAK,CAACG,MAAM,CAACjG,OAAO,CAAC,CAAC;MAAAwG,MAAA;IAAA;MAA1C,KAAAD,UAAA,CAAAhG,CAAA,MAAAiG,MAAA,GAAAD,UAAA,CAAA/F,CAAA,IAAAC,IAAA,GAA4C;QAAA,IAAjC2C,OAAK,GAAAoD,MAAA,CAAA/M,KAAA;QACZ,IAAAgN,OAAA,GAAAL,cAAA,CAAsBhD,OAAK;UAApB5J,GAAG,GAAAiN,OAAA;UAAE9M,QAAM,GAAA8M,OAAA;QAClBH,OAAO,CAAC9M,GAAG,CAAC,GAAGuM,IAAG,CAACvD,IAAI,CAAC7I,QAAM,EAAA8B,aAAA,CAAAA,aAAA,KACvBzB,OAAO;UACViJ,QAAQ,EAARA;QAAQ,EACX,CAAC;MACN;IAAC,SAAArC,GAAA;MAAA2F,UAAA,CAAA1F,CAAA,CAAAD,GAAA;IAAA;MAAA2F,UAAA,CAAAzF,CAAA;IAAA;IACD,IAAI5C,MAAM,CAACC,IAAI,CAACqH,IAAI,CAAC,CAACtL,MAAM,GAAG,CAAC,EAAE;MAC9B,IAAMoJ,WAAW,GAAGyC,IAAG,CAAC9M,MAAM,KAAK,eAAe,GAAG,OAAO,GAAG,aAAa;MAC5EqN,OAAO,CAACI,QAAQ,GAAAC,eAAA,KACXrD,WAAW,EAAGkC,IAAI,CACtB;IACL;IACA,OAAO;MAAEc,OAAO,EAAPA;IAAQ,CAAC;EACtB;EACA,IAAMP,GAAG,GAAG,IAAIzN,mBAAmB,CAAC0B,OAAO,CAAC;EAC5C+L,GAAG,CAACrM,OAAO,CAACoM,KAAK,CAAC;EAClB,OAAOC,GAAG,CAACvD,IAAI,CAACsD,KAAK,EAAE9L,OAAO,CAAC;AACnC;AACA,SAASqI,cAAcA,CAACuE,OAAO,EAAEC,IAAI,EAAE;EACnC,IAAMC,GAAG,GAAGD,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI;IAAExN,IAAI,EAAE,IAAI4E,GAAG,CAAC;EAAE,CAAC;EACvC,IAAI6I,GAAG,CAACzN,IAAI,CAAC0N,GAAG,CAACH,OAAO,CAAC,EACrB,OAAO,KAAK;EAChBE,GAAG,CAACzN,IAAI,CAAC2N,GAAG,CAACJ,OAAO,CAAC;EACrB,IAAMjN,MAAM,GAAGiN,OAAO;EACtB,IAAMrM,GAAG,GAAGZ,MAAM,CAACa,IAAI,CAACD,GAAG;EAC3B,QAAQA,GAAG,CAACyB,IAAI;IACZ,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,SAAS;IACd,KAAK,MAAM;IACX,KAAK,QAAQ;IACb,KAAK,WAAW;IAChB,KAAK,MAAM;IACX,KAAK,KAAK;IACV,KAAK,SAAS;IACd,KAAK,OAAO;IACZ,KAAK,MAAM;IACX,KAAK,SAAS;IACd,KAAK,MAAM;IACX,KAAK,KAAK;IACV,KAAK,MAAM;IACX,KAAK,kBAAkB;MACnB,OAAO,KAAK;IAChB,KAAK,OAAO;MAAE;QACV,OAAOqG,cAAc,CAAC9H,GAAG,CAACqD,OAAO,EAAEkJ,GAAG,CAAC;MAC3C;IACA,KAAK,QAAQ;MAAE;QACX,KAAK,IAAMtN,GAAG,IAAIe,GAAG,CAACwD,KAAK,EAAE;UACzB,IAAIsE,cAAc,CAAC9H,GAAG,CAACwD,KAAK,CAACvE,GAAG,CAAC,EAAEsN,GAAG,CAAC,EACnC,OAAO,IAAI;QACnB;QACA,OAAO,KAAK;MAChB;IACA,KAAK,OAAO;MAAE;QAAA,IAAAG,UAAA,GAAA5G,0BAAA,CACW9F,GAAG,CAACwE,OAAO;UAAAmI,MAAA;QAAA;UAAhC,KAAAD,UAAA,CAAA1G,CAAA,MAAA2G,MAAA,GAAAD,UAAA,CAAAzG,CAAA,IAAAC,IAAA,GAAkC;YAAA,IAAvB0G,MAAM,GAAAD,MAAA,CAAAzN,KAAA;YACb,IAAI4I,cAAc,CAAC8E,MAAM,EAAEL,GAAG,CAAC,EAC3B,OAAO,IAAI;UACnB;QAAC,SAAAlG,GAAA;UAAAqG,UAAA,CAAApG,CAAA,CAAAD,GAAA;QAAA;UAAAqG,UAAA,CAAAnG,CAAA;QAAA;QACD,OAAO,KAAK;MAChB;IACA,KAAK,cAAc;MAAE;QACjB,OAAOuB,cAAc,CAAC9H,GAAG,CAAC4E,IAAI,EAAE2H,GAAG,CAAC,IAAIzE,cAAc,CAAC9H,GAAG,CAAC8E,KAAK,EAAEyH,GAAG,CAAC;MAC1E;IACA,KAAK,OAAO;MAAE;QAAA,IAAAM,UAAA,GAAA/G,0BAAA,CACS9F,GAAG,CAACoD,KAAK;UAAA0J,MAAA;QAAA;UAA5B,KAAAD,UAAA,CAAA7G,CAAA,MAAA8G,MAAA,GAAAD,UAAA,CAAA5G,CAAA,IAAAC,IAAA,GAA8B;YAAA,IAAnB6G,IAAI,GAAAD,MAAA,CAAA5N,KAAA;YACX,IAAI4I,cAAc,CAACiF,IAAI,EAAER,GAAG,CAAC,EACzB,OAAO,IAAI;UACnB;QAAC,SAAAlG,GAAA;UAAAwG,UAAA,CAAAvG,CAAA,CAAAD,GAAA;QAAA;UAAAwG,UAAA,CAAAtG,CAAA;QAAA;QACD,IAAIvG,GAAG,CAACkF,IAAI,IAAI4C,cAAc,CAAC9H,GAAG,CAACkF,IAAI,EAAEqH,GAAG,CAAC,EACzC,OAAO,IAAI;QACf,OAAO,KAAK;MAChB;IACA,KAAK,QAAQ;MAAE;QACX,OAAOzE,cAAc,CAAC9H,GAAG,CAACsF,OAAO,EAAEiH,GAAG,CAAC,IAAIzE,cAAc,CAAC9H,GAAG,CAACuF,SAAS,EAAEgH,GAAG,CAAC;MACjF;IACA,KAAK,KAAK;MAAE;QACR,OAAOzE,cAAc,CAAC9H,GAAG,CAACsF,OAAO,EAAEiH,GAAG,CAAC,IAAIzE,cAAc,CAAC9H,GAAG,CAACuF,SAAS,EAAEgH,GAAG,CAAC;MACjF;IACA,KAAK,KAAK;MAAE;QACR,OAAOzE,cAAc,CAAC9H,GAAG,CAACuF,SAAS,EAAEgH,GAAG,CAAC;MAC7C;IACA;IACA,KAAK,SAAS;IACd,KAAK,UAAU;IACf,KAAK,aAAa;IAClB,KAAK,UAAU;IACf,KAAK,UAAU;MACX,OAAOzE,cAAc,CAAC9H,GAAG,CAACiH,SAAS,EAAEsF,GAAG,CAAC;IAC7C,KAAK,MAAM;MACP,OAAOzE,cAAc,CAAC9H,GAAG,CAACgN,MAAM,CAAC,CAAC,EAAET,GAAG,CAAC;IAC5C,KAAK,SAAS;MAAE;QACZ,OAAOzE,cAAc,CAAC9H,GAAG,CAACiH,SAAS,EAAEsF,GAAG,CAAC;MAC7C;IACA,KAAK,UAAU;MAAE;QACb,OAAOzE,cAAc,CAAC9H,GAAG,CAACiH,SAAS,EAAEsF,GAAG,CAAC;MAC7C;IACA,KAAK,QAAQ;MAAE;QACX,OAAO,KAAK;MAChB;IACA,KAAK,WAAW;MAAE;QACd,OAAO,IAAI;MACf;IACA,KAAK,MAAM;MAAE;QACT,OAAOzE,cAAc,CAAC9H,GAAG,CAAC0H,EAAE,EAAE6E,GAAG,CAAC,IAAIzE,cAAc,CAAC9H,GAAG,CAAC2H,GAAG,EAAE4E,GAAG,CAAC;MACtE;IACA,KAAK,SAAS;MAAE;QACZ,OAAO,KAAK;MAChB;IACA,KAAK,OAAO;MAAE;QACV,OAAO,KAAK;MAChB;IACA;MACIvM,GAAG;EACX;EACA,MAAM,IAAI+C,KAAK,yBAAA5B,MAAA,CAAyBnB,GAAG,CAACyB,IAAI,CAAE,CAAC;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}