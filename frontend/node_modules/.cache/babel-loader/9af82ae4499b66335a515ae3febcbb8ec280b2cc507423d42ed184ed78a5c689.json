{"ast":null,"code":"import _regeneratorValues from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/regeneratorValues.js\";\nimport _regenerator from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/regenerator.js\";\nimport _asyncToGenerator from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery(_ref) {\n  var queryFn = _ref.queryFn,\n    _ref$refetchMode = _ref.refetchMode,\n    refetchMode = _ref$refetchMode === void 0 ? \"reset\" : _ref$refetchMode,\n    maxChunks = _ref.maxChunks;\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(context) {\n      var query, isRefetch, result, stream, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, _t;\n      return _regenerator().w(function (_context2) {\n        while (1) switch (_context2.n) {\n          case 0:\n            query = context.client.getQueryCache().find({\n              queryKey: context.queryKey,\n              exact: true\n            });\n            isRefetch = !!query && query.state.data !== void 0;\n            if (isRefetch && refetchMode === \"reset\") {\n              query.setState({\n                status: \"pending\",\n                data: void 0,\n                error: null,\n                fetchStatus: \"fetching\"\n              });\n            }\n            result = [];\n            _context2.n = 1;\n            return queryFn(context);\n          case 1:\n            stream = _context2.v;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.p = 2;\n            _loop = /*#__PURE__*/_regenerator().m(function _loop() {\n              var chunk;\n              return _regenerator().w(function (_context) {\n                while (1) switch (_context.n) {\n                  case 0:\n                    chunk = _step.value;\n                    if (!context.signal.aborted) {\n                      _context.n = 1;\n                      break;\n                    }\n                    return _context.a(2, 1);\n                  case 1:\n                    if (!isRefetch || refetchMode !== \"replace\") {\n                      context.client.setQueryData(context.queryKey, function () {\n                        var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                        return addToEnd(prev, chunk, maxChunks);\n                      });\n                    }\n                    result = addToEnd(result, chunk, maxChunks);\n                  case 2:\n                    return _context.a(2);\n                }\n              }, _loop);\n            });\n            _iterator = _asyncIterator(stream);\n          case 3:\n            _context2.n = 4;\n            return _iterator.next();\n          case 4:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.v).done)) {\n              _context2.n = 7;\n              break;\n            }\n            return _context2.d(_regeneratorValues(_loop()), 5);\n          case 5:\n            if (!_context2.v) {\n              _context2.n = 6;\n              break;\n            }\n            return _context2.a(3, 7);\n          case 6:\n            _iteratorAbruptCompletion = false;\n            _context2.n = 3;\n            break;\n          case 7:\n            _context2.n = 9;\n            break;\n          case 8:\n            _context2.p = 8;\n            _t = _context2.v;\n            _didIteratorError = true;\n            _iteratorError = _t;\n          case 9:\n            _context2.p = 9;\n            _context2.p = 10;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.n = 11;\n              break;\n            }\n            _context2.n = 11;\n            return _iterator.return();\n          case 11:\n            _context2.p = 11;\n            if (!_didIteratorError) {\n              _context2.n = 12;\n              break;\n            }\n            throw _iteratorError;\n          case 12:\n            return _context2.f(11);\n          case 13:\n            return _context2.f(9);\n          case 14:\n            if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n              context.client.setQueryData(context.queryKey, result);\n            }\n            return _context2.a(2, context.client.getQueryData(context.queryKey));\n        }\n      }, _callee, null, [[10,, 11, 13], [2, 8, 9, 14]]);\n    }));\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\nexport { streamedQuery };","map":{"version":3,"names":["addToEnd","streamedQuery","_ref","queryFn","_ref$refetchMode","refetchMode","maxChunks","_ref2","_asyncToGenerator","_regenerator","m","_callee","context","query","isRefetch","result","stream","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_loop","_iterator","_step","_t","w","_context2","n","client","getQueryCache","find","queryKey","exact","state","data","setState","status","error","fetchStatus","v","p","chunk","_context","value","signal","aborted","a","setQueryData","prev","arguments","length","undefined","_asyncIterator","next","done","d","_regeneratorValues","return","f","getQueryData","_x","apply"],"sources":["C:\\Users\\als40\\Desktop\\HandsMarket\\node_modules\\@tanstack\\query-core\\src\\streamedQuery.ts"],"sourcesContent":["import { addToEnd } from './utils'\nimport type { QueryFunction, QueryFunctionContext, QueryKey } from './types'\n\n/**\n * This is a helper function to create a query function that streams data from an AsyncIterable.\n * Data will be an Array of all the chunks received.\n * The query will be in a 'pending' state until the first chunk of data is received, but will go to 'success' after that.\n * The query will stay in fetchStatus 'fetching' until the stream ends.\n * @param queryFn - The function that returns an AsyncIterable to stream data from.\n * @param refetchMode - Defines how re-fetches are handled.\n * Defaults to `'reset'`, erases all data and puts the query back into `pending` state.\n * Set to `'append'` to append new data to the existing data.\n * Set to `'replace'` to write all data to the cache once the stream ends.\n * @param maxChunks - The maximum number of chunks to keep in the cache.\n * Defaults to `undefined`, meaning all chunks will be kept.\n * If `undefined` or `0`, the number of chunks is unlimited.\n * If the number of chunks exceeds this number, the oldest chunk will be removed.\n */\nexport function streamedQuery<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>({\n  queryFn,\n  refetchMode = 'reset',\n  maxChunks,\n}: {\n  queryFn: (\n    context: QueryFunctionContext<TQueryKey>,\n  ) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>\n  refetchMode?: 'append' | 'reset' | 'replace'\n  maxChunks?: number\n}): QueryFunction<Array<TQueryFnData>, TQueryKey> {\n  return async (context) => {\n    const query = context.client\n      .getQueryCache()\n      .find({ queryKey: context.queryKey, exact: true })\n    const isRefetch = !!query && query.state.data !== undefined\n\n    if (isRefetch && refetchMode === 'reset') {\n      query.setState({\n        status: 'pending',\n        data: undefined,\n        error: null,\n        fetchStatus: 'fetching',\n      })\n    }\n\n    let result: Array<TQueryFnData> = []\n    const stream = await queryFn(context)\n\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break\n      }\n\n      // don't append to the cache directly when replace-refetching\n      if (!isRefetch || refetchMode !== 'replace') {\n        context.client.setQueryData<Array<TQueryFnData>>(\n          context.queryKey,\n          (prev = []) => {\n            return addToEnd(prev, chunk, maxChunks)\n          },\n        )\n      }\n      result = addToEnd(result, chunk, maxChunks)\n    }\n\n    // finalize result: replace-refetching needs to write to the cache\n    if (isRefetch && refetchMode === 'replace' && !context.signal.aborted) {\n      context.client.setQueryData<Array<TQueryFnData>>(context.queryKey, result)\n    }\n\n    return context.client.getQueryData(context.queryKey)!\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}