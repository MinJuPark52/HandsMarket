{"ast":null,"code":"import _createClass from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _callSuper from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"C:/Users/als40/Desktop/HandsMarket/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\n// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * Math.pow(2, failureCount), 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode !== null && networkMode !== void 0 ? networkMode : \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = /*#__PURE__*/function (_Error) {\n  function CancelledError(options) {\n    var _this;\n    _classCallCheck(this, CancelledError);\n    _this = _callSuper(this, CancelledError, [\"CancelledError\"]);\n    _this.revert = options === null || options === void 0 ? void 0 : options.revert;\n    _this.silent = options === null || options === void 0 ? void 0 : options.silent;\n    return _this;\n  }\n  _inherits(CancelledError, _Error);\n  return _createClass(CancelledError);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  var isRetryCancelled = false;\n  var failureCount = 0;\n  var isResolved = false;\n  var continueFn;\n  var thenable = pendingThenable();\n  var cancel = function cancel(cancelOptions) {\n    if (!isResolved) {\n      var _config$abort;\n      reject(new CancelledError(cancelOptions));\n      (_config$abort = config.abort) === null || _config$abort === void 0 || _config$abort.call(config);\n    }\n  };\n  var cancelRetry = function cancelRetry() {\n    isRetryCancelled = true;\n  };\n  var continueRetry = function continueRetry() {\n    isRetryCancelled = false;\n  };\n  var canContinue = function canContinue() {\n    return focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  };\n  var canStart = function canStart() {\n    return canFetch(config.networkMode) && config.canRun();\n  };\n  var resolve = function resolve(value) {\n    if (!isResolved) {\n      var _config$onSuccess, _continueFn;\n      isResolved = true;\n      (_config$onSuccess = config.onSuccess) === null || _config$onSuccess === void 0 || _config$onSuccess.call(config, value);\n      (_continueFn = continueFn) === null || _continueFn === void 0 || _continueFn();\n      thenable.resolve(value);\n    }\n  };\n  var reject = function reject(value) {\n    if (!isResolved) {\n      var _config$onError, _continueFn2;\n      isResolved = true;\n      (_config$onError = config.onError) === null || _config$onError === void 0 || _config$onError.call(config, value);\n      (_continueFn2 = continueFn) === null || _continueFn2 === void 0 || _continueFn2();\n      thenable.reject(value);\n    }\n  };\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      var _config$onPause;\n      continueFn = function continueFn(value) {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      (_config$onPause = config.onPause) === null || _config$onPause === void 0 || _config$onPause.call(config);\n    }).then(function () {\n      continueFn = void 0;\n      if (!isResolved) {\n        var _config$onContinue;\n        (_config$onContinue = config.onContinue) === null || _config$onContinue === void 0 || _config$onContinue.call(config);\n      }\n    });\n  };\n  var _run = function run() {\n    if (isResolved) {\n      return;\n    }\n    var promiseOrValue;\n    var initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise !== null && initialPromise !== void 0 ? initialPromise : config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay, _config$onFail;\n      if (isResolved) {\n        return;\n      }\n      var retry = (_config$retry = config.retry) !== null && _config$retry !== void 0 ? _config$retry : isServer ? 0 : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) !== null && _config$retryDelay !== void 0 ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      (_config$onFail = config.onFail) === null || _config$onFail === void 0 || _config$onFail.call(config, failureCount, error);\n      sleep(delay).then(function () {\n        return canContinue() ? void 0 : pause();\n      }).then(function () {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          _run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel: cancel,\n    continue: function _continue() {\n      var _continueFn3;\n      (_continueFn3 = continueFn) === null || _continueFn3 === void 0 || _continueFn3();\n      return thenable;\n    },\n    cancelRetry: cancelRetry,\n    continueRetry: continueRetry,\n    canStart: canStart,\n    start: function start() {\n      if (canStart()) {\n        _run();\n      } else {\n        pause().then(_run);\n      }\n      return thenable;\n    }\n  };\n}\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"names":["focusManager","onlineManager","pendingThenable","isServer","sleep","defaultRetryDelay","failureCount","Math","min","pow","canFetch","networkMode","isOnline","CancelledError","_Error","options","_this","_classCallCheck","_callSuper","revert","silent","_inherits","_createClass","_wrapNativeSuper","Error","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","thenable","cancel","cancelOptions","_config$abort","reject","abort","call","cancelRetry","continueRetry","canContinue","isFocused","canRun","canStart","resolve","_config$onSuccess","_continueFn","onSuccess","_config$onError","_continueFn2","onError","pause","Promise","continueResolve","_config$onPause","onPause","then","_config$onContinue","onContinue","run","promiseOrValue","initialPromise","fn","error","catch","_config$retry","_config$retryDelay","_config$onFail","retry","retryDelay","delay","shouldRetry","onFail","promise","continue","_continueFn3","start"],"sources":["C:\\Users\\als40\\Desktop\\HandsMarket\\node_modules\\@tanstack\\query-core\\src\\retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}